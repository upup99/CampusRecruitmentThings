# 	C++

##  可调用对象

C++11引入的新概念，可以像函数调用方式（使用括号运算符**`()`**进行调用）触发调用的对象就是**可调用对象（Callable Objects）**。其实可调用对象只是对C++98标准中一些调用方式进行了总结和扩展。  

在C++98标准中，可被通过函数方式调用的对象有3个，分别是**普通函数，函数指针，仿函数**。C++11中增加了**lambda表达式、bind生成对象和function对象**。

所以C++11可调用对象总计**6种**，他们分别是普通函数，函数指针，仿函数（函数对象），bind生成对象，lambda表达式和function对象

### **普通函数**  

即普通意义上的函数，包括函数名、返回值、输入/出参数和函数体

```c++
bool isEven(int value) // 接收一个参数的函数，返回值为bool类型，也称一元谓词
{
    return (value % 2 == 0); // 判断是否为偶数
}
std::vector<int> vec{2, 5, 9, 10, 11};
auto res = std::find_if(vec.begin(), vec.end(), isEven); // 返回第一个满足条件的迭代器
```

**`isEven`**就是普通函数式的可调用对象

### **函数指针**

函数指针指向的是**函数而非对象**。函数指针指向某种特定类型。可以**多次绑定**，即一个函数指针可指向多个普通函数。只要两者具有**相同的函数签名格式**（即有相同的输入/出参数，返回值）。例如：

```c++
bool isEven(int value)
{
    return (0 == value % 2);
}
using EvenDecide = bool(*)(int value); // 函数指针类型 EvenDecide 指向返回值为bool，参数为int的函数
std::vector<int> vec{2, 5, 9, 10, 11};

EvenDecide evenDecide = isEven;  // 当将函数名作为一个值使用时，该函数自动转换为指针
EvenDecide evenDecide = &isEven; // 与上面是等价的赋值语句，自动转换成函数指针，无需取地址符(&)

auto res = std::find_if(vec.begin(), vec.end(), evenDecide);  // 可以直接函数指针调用该函数，无需提前解引用(*)
auto res = std::find_if(vec.begin(), vec.end(), *evenDecide); // 与上面是等价调用
```

函数指针作为**形参**：不能定义函数类型的形参，但是形参可以是函数指针：

```C++
void useEven(int a, bool pFunc(int value)); // 第二个参数是函数类型，实际上会自动转为对应的函数指针
void useEven(int a, bool (*pFunc)(int value)); // 与上面等价，显示地将形参定义为函数指针
```

### **仿函数/函数对象**（function objects）

仿函数其实就是**重载了`operator()`运算符的类对象**。可以视为一个一般的函数，只不过这个函数功能是在一个类中的运算符operator()中实现，是一个函数对象，它将函数作为参数传递的方式来使用。（行为类似函数，故称仿函数）。实际上就是创建一个类，该类重载了operator()运算符，使得***类的实例可以像函数一样被调用***。这允许你在函数对象内部保存状态，并在调用时执行操作。

```C++
class EvenJudge
{
public:
    bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
    {
        return (0 == value % 2);
    }
};

std::vector<int> vec{ 2, 5, 9, 10, 11 };

EvenJudge evenJudge; // 仿函数/函数对象

// 1. 通过构造该类的临时对象，调用operator()重载函数
auto res1 = std::find_if(vec.begin(), vec.end(), EvenJudge());
// 2. 通过对象，隐式调用operator()重载函数
auto res2 = std::find_if(vec.begin(), vec.end(), evenJudge);
```

**优势：**

1. 函数对象可以包含成员变量，从而携带状态。这使得它们在需要保持某些数据或配置的情况下非常有用，而普通函数和函数指针无法实现这一点
2. 函数对象比函数指针的执行速度快，函数指针是通过地址调用，而函数对象是对运算符operator进行自定义来提高调用的效率
3. 函数对象广泛应用于STL算法、回调函数等场景中

### **lambda表达式**

lambda是**匿名的函数对象**，可以捕获外部变量并在函数内部使用

可以将lambda表达式视为包含公有`operator()`的匿名结构(或类)，编译器见到下面的lambda表达式时：

`[](int value) -> bool {return (0 == value % 2);}`   `-> bool`为指定返回类型，可以省略，但函数体包含**多行代码**时，必须**显示指定**返回类型

自动将其展开为**类似函数对象**的表示：

```c++
class NoName
{
public:
    bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
    {
        return (0 == value % 2);
    }
};
```

1. 通过捕获列表来使用所在区块中的变量（局部变量）

```C++
void foo()
{
    string m_s = "hello";  
    //值捕获，m_i和m_s是变量拷贝
    auto bar = [m_s]{return m_s;};
    m_s = "hello world";
    //结果是hello,foo里面储存的是捕获时的副本(按值传递)
    std::cout << bar(); // "hello"
    //引用捕获，m_i和m_s是变量本身(按引用传递)
    string m_s = "hello";
    auto bar = [&m_s]{return m_s;};
    m_s = "hello world"; 
    //结果是hello world
    std::cout << bar(); // "hello world"  
    //对作用域内所有变量采用值捕获
    auto baz = [=]{return m_s;};
    //对作用域内所有变量采用引用捕获
    auto baz = [&]{return m_s;};
}
```

2. lambda表达式有输入/出参数，返回值，函数体，唯独没有函数名，所以lambda表达式**不能通过类型名来显示声明对象**。但是可以使用auto和类型推导。例如：

```C++
auto fnIsEven = [](int value)->bool {
        return (0 == value % 2);
};
std::vector<int> vec{ 2, 5, 9, 10, 11 };
auto res1 = std::find_if(vec.begin(), vec.end(), fnIsEven);
auto res2 = std::find_if(vec.begin(), vec.end(), [](int value) {
       	return (0 == value % 2));
});
```

3. **可变lambda（Mutable Lambda）**默认情况下，lambda表达式捕获的变量是const。如果需要修改捕获的变量，可以使用**mutable**关键字

```c++
#include <iostream>

int main() {
    int n = 10;

    auto increment = [n]() mutable {
        n++;
        std::cout << "n inside lambda: " << n << std::endl;
    };

    increment(); // 输出: n inside lambda: 11
    std::cout << "n outside lambda: " << n << std::endl; // 输出: n outside lambda: 10

    return 0;
}
```

4. **泛型lambda** C++14引入了泛型lambda表达式，可以使用自动类型推断来定义参数类型

```c++
#include <iostream>

int main() {
    auto add = [](auto a, auto b) {
        return a + b;
    };

    std::cout << add(1, 2) << std::endl; // 输出: 3
    std::cout << add(1.5, 2.5) << std::endl; // 输出: 4

    return 0;
}
```

5. **捕获表达式** C++14引入了捕获表达式，使得在捕获时可以直接初始化捕获的变量

```c++
#include <iostream>
#include <vector>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    int factor = 2;

    auto multiply = [factor = factor * 2](int value) {
        return value * factor;
    };

    for (int value : vec) {
        std::cout << multiply(value) << " "; // 输出: 4 8 12 16 20
    }

    return 0;
}
```

### **bind生成对象**

**`std::bind`**是C++11引入的一个标准库函数，用于**创建可调用对象**，该对象将特定参数绑定到现有的可调用对象（例如函数、函数指针、函数对象或lambda表达式）。**`std::bind`**生成一个新的可调用对象，这个对象可以在以后调用并携带部分或全部参数。它在需要**延迟调用或部分应用参数**的情况下特别有用。 

基本语法：

```c++
auto boundFunction = std::bind(callable, arg1, arg2, ...);
// callable：可以是函数指针、成员函数指针、函数对象或lambda表达式。
// arg1, arg2, ...：可以是实际参数、占位符或其他绑定的参数。
```

**占位符：**

占位符用于指定在调用绑定函数时传递的参数位置。标准库提供了几个占位符：`_1`：表示绑定函数的第一个参数。`_2`：表示绑定函数的第二个参数 ...

占位符在`std::placeholders`命名空间中定义，通常通过`using namespace std::placeholders;`来使用它们

1. **`bind`普通函数**：其实普通函数可以理解为：一个特殊的函数指针，一个const 引用类型的函数指针（一旦绑定永远不许修改）

```C++
bool isEven(int value)
{
	return (0 == value % 2);
}

auto f = std::bind(isEven, std::placeholders::_1); // f 即bind生成的可调用对象 注意有一个占位符
std::vector<int> vec{ 2, 5, 9, 10, 11 };
auto res = std::find_if(vec.begin(), vec.end(), f);

// 若发生函数重载，bind需要指明函数类型来确定应该绑定哪个函数
bool isEven(long long value)
{
    return (0 == value % 2);
}
// 使用 static_cast 明确指定函数的类型，从而消除歧义
auto f = std::bind(static_cast<bool(*)(long long)>(isEven), std::placeholders::_1); 
```

2. **`bind`函数指针**：

```C++
bool isEven(int value)
{
	return (0 == value % 2);
}
using EvenDecide = bool(*)(int value); 
EvenDecide evenDecide = isEven;

auto f = std::bind(evenDecide, std::placeholders::_1); // f 即bind生成的可调用对象
std::vector<int> vec{ 2, 5, 9, 10, 11 };
auto res = std::find_if(vec.begin(), vec.end(), f);
```

3. **`bind`函数对象** :

```c++
struct EvenJudge
	{
    bool operator() (int value) // 重载函数调用运算符，使得该类的实例成为仿函数，可被调用
    {
        return (0 == value % 2);
    }
};

std::vector<int> vec{ 2, 5, 9, 10, 11 };

EvenJudge evenJudge; // 函数对象

auto f = std::bind(evenJudge, std::placeholders::_1);
// auto f = std::bind(EvenJudge(), std::placeholders::_1); //上面的等价
std::vector<int> vec{ 2, 5, 9, 10, 11 };
auto res = std::find_if(vec.begin(), vec.end(), f);
```

4. **`bind` lambda表达式**：

```c++
auto fnIsEven = [](int value) {
    return (0 == value % 2);
};
auto f = std::bind(fnIsEven, std::placeholders::_1);
std::vector<int> vec{ 2, 5, 9, 10, 11 };
auto res = std::find_if(vec.begin(), vec.end(), f);
```

5. **`bind`** 类的成员函数：

```C++
class MyClass
{
public:
    void display(int value) // 类的成员函数
    {
        std::cout << "Value: " << value << std::endl;
    }
    void display(double value) // 类的成员函数
    {
        std::cout << "Value: " << value << std::endl;
    }
};

int main()
{
    MyClass obj;
    auto f = std::bind(&MyClass::display, &obj, std::placeholders::_1); // 记得第二个参数传类实例对象的this指针
    f(11); // 输出：Value::11
	
    // 若发生成员函数重载，bind需要指明函数类型来确定应该绑定哪个函数
    auto f = std::bind(static_cast<void(MyClass::*)(double)>(&MyClass::display), &obj, std::placeholders::_1>);
    return 0;
}
```

`bind`的作用在于它可以将所有可调用对象进行**归一化调用**。大大的降低了可调用对象的差异性。可增加程序的**可维护性和扩展性**  

### **function对象**

**`std::function<>`**是C++11标准引入的类模板，专门用来包装可调用的对象。

**`std::function` **的模板参数指定了可调用对象的签名，即返回类型和参数类型列表。例如，`std::function<int(int, int)>` 表示一个返回 `int`，并接受两个 `int` 参数的可调用对象。

因此，有了**`std::function<>`**，不同实现的各种函数对象可以共用同一种调用形式(**call signature**)。

实例化以后的**`std::function<>`**，例如`std::function<int(int)>`，可以被理解为是某种**特定调用形式**的一个***容器***。

```C++
int add(int a, int b) {
    return a + b;
}
struct Add {
    int operator()(int a, int b) const {
        return a + b;
    }
};
using pADD = int(*)(int a, int b);
pADD padd = add;
int main() {
    std::function<int(int, int)> func = add; // 包装普通函数
    std::function<int(int, int)> func = [](int a, int b) -> int{return a + b;}; // 包装lambda表达式
    std::function<int(int, int)> func = Add(); // 包装函数对象(仿函数)
    std::function<int(int, int)> func = padd; // 包装函数指针
    auto func_bind = std::bind(add, std::placeholders::_1, std::placeholders::_2);
    std::function<int(int, int)> func5 = (func_bind); // 包装bind对象
    std::cout << func(2, 3) << std::endl; // 输出: 5
    return 0;
}
```

### 函数签名

在C++编程中，**函数签名（Function Signature）**是函数唯一标识的一部分，用于**区别不同的函数**。函数签名包括**函数的名称和参数类型列表**，但***不包括***返回类型、参数名称和参数的默认值。

函数签名的**组成部分**：1. 函数名称：函数的标识符。 2. 参数类型列表：函数参数的类型及其顺序。
函数签名用于在**函数重载和模板实例化**时区别不同的函数。它在编译过程中**帮助编译器确定应该调用**哪个具体的函数。

```C++
void func(int a); 		    // Signature：func(int)
void func(double b);        // Signature：func(double)
void func(int a, double b); // Signature：func(int, double)
```

## 线程创建

### 调用约定（Calling Convention）

用于指定函数如何**接收参数和返回值**，以及函数调用时**堆栈的管理方式**

为什么要用： 调用约定对于函数如何**传递参数、管理堆栈以及返回值的方式**进行规范化。不同的编译器、平台或函数库可能会使用不同的调用约定。使用明确的调用约定可以确保在不同编译单元或不同语言之间进行一致且正确的函数调用。

- **`__cdecl`**  C和C++编程中，默认的调用约定，这是大多数编译器在没有指定其他调用约定时所使用的默认方式，尤其是在x86架构的Windows平台上

  1. **参数传递顺序**：参数***从右向左***传递。这意味着最右边的参数首先被压入堆栈。
  2. **堆栈清理**：***调用者***负责清理堆栈（Caller cleans the stack）。在函数返回后，调用函数的代码负责从堆栈中移除传递的参数。
  3. **函数名称修饰**：使用前导下划线和原名，例如函数 `foo` 会被修饰为 `_foo`
  4. **可变参数支持**：支持可变参数函数（如 `printf`）

- **`__stdcall`**：参数***从右向左***传递，由***被调用者***清理堆栈。常用于Windows API函数，函数名称修饰：前缀+下划线，后缀加@和参数的字节数(十进制)

  ​						如：`void __stdcall myFunction(int a, double b);`会被修饰为：`_myFunction@12`

- **`__thiscall`**：C++类的**成员函数**默认使用的调用约定，`this`指针通过寄存器传递，其他参数从右向左传递

- **`__fastcall__`**：部分参数通过寄存器传递，减少堆栈操作，提高调用效率

### **`pthread_create()`**

Linux平台上使用**`pthread_create`**这个API来创建线程，其函数签名如下：

```C++
int pthread_create(pthread_t *thread, 
				   const pthread_attr_t *attr,
                   void *(*start_routine) (void *), 
                   void *arg);
```

其中：

return: 如果成功创建线程，返回0；如果创建失败，则返回响应的错误码，常见的错误码有`EAGAIN`：资源暂时不可用，如：尝试**非阻塞地**读取一个**空的**非阻塞套接字时、`EINVAL`：无效的参数、`EPERM`：无权限操作

para1: **输出参数**，如果线程创建成功，通过这个参数可以得到创建成功的**线程ID**

para2: 指定了该线程的**属性**，一般设置为NULL，表示使用默认属性

para3: **线程函数指针**，调用方式必须是**`__cdecl`**，必须具有如下原型：`void * function (void *)` 即返回`void*`且参数`void*`

para4：通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个**`void*`**类型，可以方便我们最大化地传入**任意多**的信息给线程函数

### `CreateThread()`

Windows上创建线程使用**`CreateThread`**，其函数签名如下：

```C++
HANDLE CreateThread(
  LPSECURITY_ATTRIBUTES   lpThreadAttributes,
  SIZE_T                  dwStackSize,
  LPTHREAD_START_ROUTINE  lpStartAddress,
  LPVOID                  lpParameter,
  DWORD                   是一个32位无符号整型（DWORD），一般设置为0，表示创建好线程后立即启动线程的运行,
  LPDWORD                 lpThreadId
);
```

其中：

return: Windows上使用**句柄**（HANDLE类型）来管理线程对象，句柄本质上是**内核句柄表中的索引值**。如果成功创建线程，返回该线程的句柄；如果创建失败，返回NULL

para1：线程的安全属性，一般设置为NULL

para2：线程的栈空间大小，单位为字节数，一般指定为0，表示使用默认大小。

para3: **线程函数指针**，为线程函数，其类型是**`LPTHREAD_START_ROUTINE`**，这是一个函数指针类型，其定义如下:

`typedef DWORD ( __stdcall *LPTHREAD_START_ROUTINE )(LPVOID lpThreadParameter);`   

即windows下的线程函数，返回值为 `DWORD`，调用方式必须是`__stdcall`(**所以需要在函数名前显示指定函数调用方式**)，参数类型必须为`LPVOID`

para4：通过这一参数可以在创建线程时将某个参数传入线程函数中，由于这是一个**`void*`**类型，可以方便我们最大化地传入**任意多**的信息给线程函数

para5：是一个32位无符号整型（`DWORD`），一般设置为0，表示创建好线程后立即启动线程的运行

para6：**输出参数**，线程创建成功返回的线程ID，这也是一个32位无符号整数（`DWORD`）的指针（`LPDWORD`）

```
# define WINAPI __stdcall
# define CALLBACK __stdcall
typedef void* LPVOID;
typedef unsigned long DWORD; // 常用来保存地址或者存放指针 一个word是2字节，double word就是4字节，也就是32bit的无符号整数
typedef unsigned long* LPDWIRD;
```

```c++
_beginthread();   // __cdecl
_beginthreadex(); // __cdecl or __stdcall
CreateThread();   // __stdcall
```

### `_beginthreadex()`

Windows CRT提供的线程创建函数，这里的CRT，指的是**C** **R**un**t**ime（C运行时），通俗地说就是C函数库。在Windows操作系统上，微软实现的C库也提供了一套用于创建线程的函数（当然这个函数底层还是调用相应的操作系统平台的线程创建 API）。在实际项目开发中推荐使用这个函数来创建线程而不是使用**CreateThread()**，其函数签名如下：

```C++
uintptr_t _beginthreadex( 
   void *security,  
   unsigned stack_size,  
   unsigned ( __stdcall *start_address )( void * ),  
   void *arglist,  
   unsigned initflag,  
   unsigned *thrdaddr   
);  
```

基本与 `CreateThread()`

### `std::thread`

无论是Linux还是Windows上创建线程的API，都有一个非常不方便的地方，就是线程函数的签名必须是**固定的格式**（参数个数和类型、返回值类型、调用约定都有要求）。C++11新标准引入了一个新的类**`std::thread`**（需要包含头文件`<thread>`），使用这个类可以将**任何签名形式**的函数（**可调用对象**）作为线程函数。

```C++
// 函数作为线程函数
void foo(int x) {
    std::cout << "foo: " << x << std::endl;
}

int main() {
    // 使用函数作为线程函数
    std::thread t1(foo, 42); // 输出：foo: 42

    // 使用 lambda 表达式作为线程函数
    int y = 100;
    std::thread t2([&]() { // 输出：lambda: 100
        std::cout << "lambda: " << y << std::endl;
        });

    t1.join(); // 阻塞等待该线程结束
    t2.join(); // 阻塞等待该线程结束

    return 0;
}
```

- 一些**接口**：

![image-20240601160308984](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745025.png) 

- 注意如何按**引用传参**：

```C++
#include <iostream>
#include <thread>

void func(int& n) {
    ++n;
}

int main() {
    int value = 42;
    std::thread t(func, std::ref(value)); // 引用传参
    t.join();
    std::cout << "Value after thread execution: " << value << std::endl;
    return 0;
}
```

- 线程任务的移动和交换  

  没有两个 **`std::thread`** ***对象***会表示同一执行线程，因为 **`std::thread`** 是**可移动构造且可移动赋值**，但**不是**可复制构造或可复制赋值的

```C++
auto task(){/* 某些计算过程 */}
std::thread t1(task);
std::thread t2 = t1; //错误: 线程不可以复制
std::thread t3{t1}; // 错误: 线程不可以拷贝构造

//一次只有一个线程对象负责一个任务。但是，与线程对象关联的任务是可移动的：
std::thread t4 = std::move(t1); //正确: t4现在运行task，t1变成一个空对象
```

​		**`swap()`** 方法用于交换两个 **`std::thread`** 对象的内容。这个方法可以用于线程的安全传递，避免手动管理线程资源。

```C++
std::thread t1(func1);
std::thread t2(func2);
t1.swap(t2); // 交换线程 t1 和 t2 的内容
```

- 线程的退出

  **`detach`** 启动的线程自主在后台运行，当前的代码继续往下执行，不等待新线程结束

  - 调用detach表示thread对象和其表示的线程完全分离
  - 分离之后的线程是不在受约束和管制，会单独执行，直到执行完毕释放资源，可以看做是一个daemon线程
  - 分离之后thread对象不再表示任何线程
  - 分离之后`joinable() == false`，即使还在执行

  **`join`**  等待启动的线程完成，才会继续往下执行
  
- **必须保证线程函数运行期间，其线程对象有效**

```c++
void threadproc()
{
    // ... 
}
void func()
{
    std::thread t(threadproc); // 此时线程对象 t 是局部变量，func 调用结束后也就被销毁了，而此时线程函数仍在运行，程序会崩溃
}
// .detach() 让线程对象与线程函数脱离关系，这样即使线程对象被销毁，仍然不影响线程函数的运行
void func()
{
    std::thread t(threadproc);
    t.detach(); 
    // 然而，在实际开发中，并不推荐这么做，原因是我们可能需要使用线程对象去控制和管理线程的运行和生命周期。所以，我们的代码应该尽量保证线程对象在线程运行期间有效，而不是单纯地调用detach方法使线程对象与线程函数的运行分离
}
```

## 等待线程结束

### Linux

Linux线程库提供了**pthread_join**函数，用来等待某线程的退出并接收它的返回值。这种操作被称为**汇接**（join），**pthread_join**函数签名如下：

```c++
int pthread_join(pthread_t thread, void** retval); // _1：需要等待的线程id _2:输出参数，用于接收等待退出的线程的退出码（Exit Code）
```

**pthread_join**函数等待目标线程退出期间会挂起当前线程（调用pthread_join的线程），被挂起的线程处于**等待状态，不会消耗任何CPU时间片**。直到目标线程退出后，调用pthread_join的线程会被**唤醒**，继续执行接下来的逻辑 （和**忙等**不一样，这里是**阻塞等待**，不消耗CPU资源）

```c++
pthread_t fileThreadID;
pthread_create(&fileThreadID, NULL, fileThreadFunc, NULL);
int* retval;
pthread_join(fileThreadID, (void**)&retval);
```

### Windows

Windows下使用API **WaitForSingleObject**或**WaitForMultipleObjects**函数，前者用于等待**一个线程**结束，后者可以同时等待**多个线程**结束。这是两个非常重要的函数，它们的作用不仅可以用于等待线程退出，还可以用于**等待其他线程同步对象**。与Linux的**pthread_join**函数不同，Windows的**WaitForSingleObject**函数提供了可选择等待时间的精细控制

```c++
HANDLE hFileThread = CreateThread(NULL, 0, FileThreadFunc, NULL, 0, &dwFileThreadID);
//无限等待，直到线程退出，否则程序将一直挂起。
WaitForSingleObject(hFileThread, INFINITE);
```

### std::thread

**std::thread**的**join**方法就是用来等待线程退出的函数。当然使用这个函数时，必须保证该线程还处于**运行中**状态，也就是说等待的线程必须是可以“**join**” 的，如果需要等待的线程已经退出，此时调用**join**方法，程序会产生崩溃。因此，C++11的线程库同时提供了一个**joinable**方法来判断某个线程是否可以join，如果不确定当前线程是否可以”join”，可以先调用**joinable**函数判断一下是否可以“join”

```c++
std::thread t(FileThreadFunc);
if (t.joinable())
		t.join();
```

## 类的成员函数作为线程函数

### **`pthread_create() `**和 **`CreateThread()`** 的做法：

假定一个类的成员函数`threadFunc()`

```C++
class CThread
{
public:
    Thread();
    ~Thread();

    void start();
    void stop();

    void* threadFunc(void* arg); // 实例方法
};
```

无论是类的实例方法（非静态成员函数）还是静态方法（静态成员函数），C++编译器在编译时都会将这些函数”翻译“成**全局函数**，即去掉类的域限制。对于实例方法，为了保证类方法的正常功能，C++编译器在翻译时，会将类的实例对象地址（也就是**this指针**）作为第一个参数传递给该方法，也就是说，翻译后的`threadFunc`的签名变成了如下形式（伪代码）

```c++
void* threadFunc(Thread* this, void* arg);
```

这样的话，就不符合**线程函数签名要求**了。因此如果使用类方法作为线程函数则***只能是类的静态方法而不能是类的实例方法***。

如果不使用C++11的语法，那么线程函数只能使用类的静态方法，且函数签名必须符合线程函数的签名要求。如果是类的静态方法，那么就**没法访问类的实例方法及成员**了，为了解决这个问题，我们在实际开发中往往会在创建线程时将当前对象的地址（**this**指针）传递给线程函数，然后在线程函数中，将该指针**转换成原来的类实例**，再通过这个实例就可以访问类的所有方法了。

```C++
class CThread
{
public:
    CThread();
    ~CThread();
    
    static void* ThreadEntry(void* arg) // 线程入口函数
    {
        CThread* thiz = (CThread*)arg;
        thiz->threadFunc();
    }
    void* threadFunc(void* arg); // 实例方法
};
pthread_create(&m_thread, &attr, &CThread::ThreadEntry, this); // 传this指针给线程入口函数，然后在函数中执行真正的工作函数
```

### **`std::thread`** 的做法：

如果是使用C++11的**`std::thread`**类就没有这个限制，即使类成员函数是类的实例方法也可以，但是必须**显式**地将线程函数所属的类对象实例指针（在类的内部就是this指针）作为**构造函数参数**传递给**`std::thread`**，还是需要传递类的this指针，这在本质上是一样的

```C++
class CThread
{
public:
    Thread();
    ~Thread();

    void* threadFunc(void* arg); // 实例方法
};
CThread thread;
std::thread t(&CThead::threadFunc, &thread, arg); // 传this指针
```

## 智能指针

==**应用场景**==：

1. 需要用原始指针的地方，应该优先用引用
2. 不能用引用的地方，才考虑原始指针，例如某些函数的返回值，可能需要空值的情况，引用不好表示空值，这时候就可以用指针
3. 如果指针不需要调用者使用内存，那就用原始指针。如果需要调用者释放内存，可以用智能指针
4. 在需要使用指针的地方，如果可以用`unique_ptr`，那么可以多用。因为 `unique_ptr`很多时候是**zero cost**
5. `shared_ptr`有开销，可以少用，一般来说同步程序不需要使用它。复杂的异步程序有大量的回调函数，某些变量的生命周期变得不明确，认为控制合适释放变得非常困难，这时候`shared_ptr`就可以让问题简化

**为什么**要有智能指针：

C++中引入智能指针的主要目的是为了解决**动态内存管理**的问题（C++不像Java等语言有垃圾回收机制 C+对性能要求极高，所以没有垃圾碎片回收机制，对于内存的释放要特别小心）。传统的指针（**裸指针**）在使用时需要手动分配和释放内存，容易出现**==内存泄漏==（未 `delete`）和==悬挂指针==（未 `ptr = nullptr`）**等问题。智能指针通过封装裸指针，并提供自动内存管理功能，使得内存资源可以更安全、高效地管理。基于**`RAII`**思想，我们把指针托管给一个对象，利用对象的生命周期来管理指针。

智能指针的**关键和难点**是处理**==拷贝==** (即在智能指针模板类中对**拷贝构造函数和赋值重载函数**的设计)

### `auto_ptr`

在智能指针被复制时，将对象的所有权**转移**给目标指针，并**重置**原来的指针(**破坏性复制**)

1. 拷贝构造和赋值运算不能接收 **const引用**， 因为内部会重置源智能指针
2. 不适用于 STL 容器，因为破坏性复制导致源指针失效
3. 不支持对象数组的内存管理

```c++
// 管理权转移，转移后不能使用源对象
auto_ptr(auto_ptr& ap)                 // auto_ptr的拷贝构造函数
    :ptr(ap.ptr)
{
    ap.ptr = nullptr;                  // 破坏性复制
}

auto_ptr<T> operator=(auto_ptr<T>& ap) // auto_ptr 的赋值重载函数
{
    if (ptr != ap.ptr)
    {
        ptr = ap.ptr;
        ap.ptr = nullptr;              // 破坏性复制
    }
    return ptr;
}
```

### `unique_ptr`

1. 独占资源所有权，且禁止拷贝构造与赋值重载(但是实现了移动构造与移动赋值，故有2)

   ```C++
   unique_ptr(const unique_ptr<T>& up) = delete; 				// 删除拷贝构造
   unique_ptr<T>& operator=(const unique_ptr<T>& up) = delete; // 删除赋值重载
   ```

2. 支持**右值引用**的拷贝构造与赋值重载(即支持**移动构造与移动赋值**，move_only)，支持**函数返回值**赋值，本质还是右值引用

3. 支持对象数组的管理

```c++
std::unique_ptr<int> func()
{
	std::unique_ptr<int> ptr(new int(10));
	return ptr;
}

std::unique_ptr<int> ptr1(new int(5));
std::unique_ptr<int> ptr2(ptr1);	    // 错误！不支持拷贝构造
std::unique_ptr<int> ptr3 = ptr1;	    // 错误！不支持赋值重载

std::unique_ptr<int> ptr2(std::move(ptr1));  // 正确，支持移动构造，语句结束后 ptr1=nullptr
std::unique_ptr<int> ptr3 = std::move(ptr1); // 正确，支持移动赋值，语句结束后 ptr1=nullptr

ptr1 = func(); // 正确，支持函数返回值赋值(本质还是移动赋值)

std::unique_ptr<int[]> uptr(new int[10]); // 支持对象数组的管理
```

 4. 使用`std::make_unique`, 用于创建一个 `std::unique_ptr` 智能指针，并将其指向一个新分配的对象

    好处：a. **异常安全**：如果在构造对象时发生异常（比如在构造参数时），已分配的内存会被自动回收，这样就不会发生内存泄漏

    ​			b. **简洁的语法**：使用 `std::make_unique` 能用一行代码完成智能指针的创建和对象的初始化

    ​			c. **避免使用裸指针**：使用 `std::make_unique` 可以减少对 `new` 和 `delete` 的直接调用，避免裸指针的使用，使代码更现代化和安全

```C++
std::unique_ptr<int> ptr1 = std::make_unique<int>(5);
std::unique_ptr<int[]> uptr = std::make_unique<int[]>(10); // 数组的智能指针，数组中有10个int
```

### `shared_ptr`

1.  允许多个智能指针可以指向同一块资源，并且能够保证共享的资源只会被释放一次

2. 通过**==引用计数==**来实现，多个`shared_ptr`对象之间共享资源：（**引用计数存放在==控制块==中，其中还有weak count、自定义删除器等**）

   a. 内部有一个成员变量`long int* _pcount`，它指向一块**存储引用计数**的空间，引用计数用来记录该份资源被几个对象共享

   b. 当进行拷贝构造or赋值重载时，引用计数+1，即：`++(*_pcount)`

   c. 当一个`shared_ptr`对象被销毁时（调用析构函数），析构函数内就会将该计数减1,即 `--(*_pcount)`

   d. 如果引用计数减为0后，则表示自己是最后一个使用该资源的`shared_ptr`对象，必须释放资源

   e. 赋值重载：①`ptr1 = ptr1`，自赋值不作处理; ②`ptr1 = ptr2`，若`ptr1`和`ptr2`指向**同一**块空间, 不作处理， 若指向**不同**空间：将`ptr1`的引用计数`-1`     -> 判断是否需要释放原资源 -> 将`ptr1` 指向`ptr2`的资源 -> `ptr2`的引用计数`+1` 		

```c++
std::shared_ptr<int> ptr1 = std::make_shared<int>(10); // *_pcount = 1
std::shared_ptr<int> ptr2(ptr1);					   // *_pcount = 2
std::shared_ptr<int> ptr3 = ptr1;					   // *_pcount = 3
```

 	3. **循环引用**问题：两个或多个对象相互引用，或者⼀些复杂的数据结构，如双向链表中，存在多个引⽤路径等情况下，可能会存在循环引用问题，导致资源无法
 	 被释放掉。

```C++
struct ListNode
{
	std::shared_ptr<ListNode> _pre;
	std::shared_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> node1 = std::make_shared<ListNode>();
	std::shared_ptr<ListNode> node2 = std::make_shared<ListNode>();

	node1->_next = node2;
	node2->_pre = node1;
	printf("node1 count is: %d\n", node1.use_count()); // node1 count is: 2
	printf("node2 count is: %d\n", node2.use_count()); // node2 count is: 2

	return 0;
}
```

### `weak_ptr`

1. `weak_ptr`不参与资源的管理和释放，可以使用`shared_ptr`或`weak_ptr`来构造或赋值，但是不能直接使用裸指针来构造`weak_ptr`对象
2. `weak_ptr`在进行拷贝构造和赋值时，不增加引用计数，由于`weak_ptr`不参与资源管理，也不需要显示定义析构函数来释放资源
3. 没有`operator*`函数和`operator->`成员函数，不具有一般指针的行为
4. 严格意义上并不是智能指针，其出现，就是为了解决`shared_ptr`的循环引用问题。
5. `weak_ptr`不会增加引用计数，可以安全地观察`shared_ptr`智能指针，在需要的时候，可以用`weak_ptr`创建一个临时的`shared_ptr`来访问或使用其资源。因此，使用`weak_ptr`取代在循环引用中的一个`shared_ptr`,可以打破循环引用而不引发内存泄漏

```c++
struct ListNode
{
	std::weak_ptr<ListNode> _pre;
	std::weak_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> node1 = std::make_shared<ListNode>();
	std::shared_ptr<ListNode> node2 = std::make_shared<ListNode>();

	node1->_next = node2;
	node2->_pre = node1;
	printf("node1 count is: %d\n", node1.use_count()); // node1 count is: 1
	printf("node2 count is: %d\n", node2.use_count()); // node2 count is: 1

	return 0;
}
```

### 自定义删除器**（Custom Deleters）**

1. 可以为 `std::unique_ptr` 和 `std::shared_ptr` 提供一个**自定义删除器**，这在需要特殊逻辑来销毁对象时很有用，例如释放非内存资源
2. 这个自定义删除器可以是**函数指针**、**仿函数**、**lambda表达式** 等可调用对象
3. 举例：指向**数组**的智能指针，析构时应该使用`delete[]` 、指向**文件**的智能指针，析构时应该使用`fclose()` 

```c++
struct ListNode
{
	std::weak_ptr<ListNode> _pre;
	std::weak_ptr<ListNode> _next;
};

int main()
{
	std::shared_ptr<ListNode> ptr1(new ListNode[10], [](const ListNode* arry) // lambda表达式做自定义删除器
		{
			printf("delete[] for array!\n"); // delete[] for array!
			delete[] arry; });
	return 0;
}
```

### `shared_ptr`的线程安全

**线程不安全的实质就是相同的代码，不同线程执行先后不同结果不同**

1. 多线程代码操作的是同一个`shared_ptr`的对象(**赋值)**是**线程不安全**的

```c++
// 由于赋值操作涉及原内存释放、修改指针指向等多个修改操作，其过程不是原子操作，因此对shared_ptr进行并发赋值不是线程安全的
std::shared_ptr<int> global_sp = std::make_shared<int>(10);
std::shared_ptr<int> global_sp2 = std::make_shared<int>(20);

void fn(std::shared_ptr<int>& sp) { // 引用传参，故操作的是同一个shared_ptr对象
	 sp = global_sp;
}
void fn2(std::shared_ptr<int>& sp) {
	sp = global_sp2;
}
int main() {
	std::shared_ptr<int> sp1 = std::make_shared<int>(5);
	std::thread t1(fn, std::ref(sp1)); 
	std::thread t2(fn2, std::ref(sp1));
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp1); // sometimes 20 sometimes 10

	return 0;
}
```

2. 多线程代码操作的不是同一个`shared_ptr`的对象(**复制**)，但不同的`shared_ptr`指向了相同的内存，此时是线程安全的（引用计数是线程安全的）

```c++
// 进行并发拷贝，对数据指针和控制块指针仅进行读取并复制，然后对引用计数进行递增，而引用计数增加是原子操作。因此是线程安全的
std::shared_ptr<int> global_sp = std::make_shared<int>(10);
std::shared_ptr<int> global_sp2 = std::make_shared<int>(20);

void fn(std::shared_ptr<int> sp) { // 注意这里没有引用传参，故是复制，操作的不是同一个share_ptr对象
	 sp = global_sp;
}
void fn2(std::shared_ptr<int> sp) {
	sp = global_sp2;
}
int main() {
	std::shared_ptr<int> sp1 = std::make_shared<int>(5);
	std::thread t1(fn, sp1);
	std::thread t2(fn2, sp1);
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp1); // always 5

	return 0;
}
```

3. `shared_ptr`本身不是一个线程安全的STL，因此并发读写对应内存区域是不安全的

```C++
std::shared_ptr<int> sp = std::make_shared<int>(0);
void fn() {
	for (int i = 0; i < 10000; i++) {
		(*sp)++;
	}
}

int main() {
	
	std::thread t1(fn);
	std::thread t2(fn);
	
	t1.join();
	t2.join();

	printf("sp1 = %d\n", *sp); // sometimes: 20000 sometimes:16625

	return 0;
}
```

### `enable_shared_from_this`

1. 什么时候会创建控制块

```C++
// a. std::make_shared会创建控制块。
// b. 从 std::unique_ptr 上构造出 std::shared_ptr的时候，会创建控制块。
// c. 从原始指针上构造 std::shared_ptr的时候会创建控制块
```

2. `this`指针作为`std::shared_ptr`构造函数实参的时候可能导致创建多个控制块，析构时导致非法行为

```C++
class test
{
public:
	test() {}
	~test() {
		printf("Destructor!\n");
	}
	std::shared_ptr<test> getptr() {
		return std::shared_ptr<test>(this);
	}
};

int main() {
	std::shared_ptr<test> sp = std::make_shared<test>(); // 创建了一个管理 this 的控制块
	std::shared_ptr<test> sp2 = sp->getptr(); // 又创建了一个管理 this 的控制块
	// 析构时会 double free,以下为打印输出：
	// Destructor!
	// double free or corruption(out)
	// Aborted

	return 0;
}
```

3. 针对以上问题，为了避免**double free** 同时能方便地在类的成员函数中获取管理类对象的`shared_ptr`,使用`std::enable_shared_from_this`这个模板类

   `std::enable_shared_from_this`定义了一个成员函数：`shared_from_this()`，它会创建指向当前对象的`std::shared_ptr`，会去关联同一个已经创建的**控制块**，解决了多个控制块的问题

```c++
class test: public std::enable_shared_from_this<test> // 继承 std::enable_shared_from_this<>这个模板类
{
public:
	test() {}
	~test() {
		printf("Destructor!\n");
	}
	std::shared_ptr<test> getptr() {
		return shared_from_this();
	}
};

int main() {
	std::shared_ptr<test> sp = std::make_shared<test>(); // 创建了一个管理 this 的控制块
	std::shared_ptr<test> sp2 = sp->getptr(); // p2 与 p1 共享一个控制块，不会创建第2个
	// 析构时不会 double free,以下为打印输出
	// Destructor!

	return 0;
}
```

4. **控制块**：`shared_ptr`中有两个指针，一个指向实际对象，一个指向**控制块**（指向引用计数并不全面）

![image-20240615124052217](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406151241623.png)  

![image-20240615124125185](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406151241624.png) 

## 关键字

### static const

**static**：修饰符，用于控制变量的**存储方式和可见性**

- **控制存储方式**：static被引入以告知编译器，将变量存储在程序的**静态存储区**(**.data .bss**)而非**栈上空间**（故==**生命周期**==也被改变了）
- **控制可见性**：把变量的可见范围限制在编译单元中，使它成为一个内部连接，不具备外部连接属性，在外部**extern**也没用

==以下五个用处，前 3 个 C/C++ 共享，后 2 个 C++ 独占==

- **静态局部变量**：用于函数体内部修饰变量，这种变量的生命周期长于该函数(在**.data .bss**)，随着函数的第一次调用而初始化(仅一次)，却不随函数调用结束而销毁
- **静态全局变量**：修饰全局变量，表示该变量只在本文件可见(控制可见性)，不具有全局变量的外部连接属性，在其他文件中可以定义相同名字的变量
- **静态函数**：与静态全局变量类似，不能被外部文件所用，其他文件中可以定义相同名字的函数，不会冲突
- **静态成员变量**：生命周期长于该类的对象(instance)， 类的所有对象**共享一份**静态成员变量(静态存储区**.data .bss**)，并**不占用**类对象的内存空间。故静态成员变量也称**类变量**，普通成员变量称**实例变量**；因为与对象无关，定义时就要分配内存，不能在类声明中定义
- **静态成员函数**：被类的所有对象**共享**；可以直接用`A::func()`调用；不能访问非静态成员变量or函数(**无this指针**)，但是非静态可以访问静态;因为**先于类的对象而存在**，怎么可能知道后面发生的事呢？ 而对象实例化时是知道类声明中所有事的		

==**初始化时机**==：

- 对于C语言的全局和静态变量，初始化发生在任何代码执行之前，属于编译期初始化
- 而C++标准规定：全局或静态对象当且仅当对象首次用到时才进行构造

**const**：修饰符，告诉编译器指定了一个变量在初始化后**不能被修改**的特性，其内存分配取决于其修饰变量的位置和作用域

- **顶层const**：指针本身就是一个常量		

  ```c++
  int * const a = 10; // const的左结合
  ```

- **底层const**：指针指向一个常量

  ```C++
  const int *a = 10; 
  ```

- **const成员函数**：本质上是修饰了**this指针**

  ```c++
  class A
  {
      public:
      void func () {} // 普通成员函数默认签名为：(A* const this, ...), 即接收一个顶层const的this指针作为参数 
      void func2 () const {} // const成员函数默认签名为：(const A* const this, ...), 即接收一个顶层+底层const的this指针作为参数
  }
  A a; // 此时 a 的this指针类型为 A* const this (默认顶层const)
  const A b; // 此时 ab的this指针类型为 const A* const this (顶层+底层const)
  
  // 非 const 对象可以访问任意成员函数
  a.func(); // OK, A* const this 传参给 func()    
  a.func2(); // OK, A* const this 传参给 func2()
  
  // const 对象只能访问 const 成员函数
  b.func(); // fail! const A* const this 传参给 func() 会被认为有修改底层const的风险
  b.func2(); // OK const A* const this 传参给 func2()
  ```

### constexpr volatile mutable	

**constexpr**：真正的常量

- **与const的区别**：const修饰的变量可以在运行时才初始化，而constexpr则一定会在**编译期初始化**。故 constexpr 才是名副其实的**常量**，const 更多表示的是 **read-only** 语义
- **用于指针**：`constexpr int* a = 10;` 与 const 不同，constexpr 只有**顶层 const **语义，即这里是修饰指针 a 表明 a 是常量，而非指针指向的对象

**volatile**：直接从从**原始内存地址**读取，而非CPU的寄存器， 类型修饰符，**确保指令不会被编译器的优化而忽略**

```c++
int main()
{
	int i = 10; // volatile int i = 10; // 每次都会从 i 的原始内存地址中取值
	int a = i;

	printf("%d", i);

	//下面汇编语句的作用就是改变内存中i的值，但是又不让编译器知道
	__asm
	{
		mov dword ptr[ebp - 4], 20h
	}
	int b = i;
	printf("i=%d", b);
	return 0;
}
// debug版本模式下运行，输出 i = 10 i = 32
// release版本模式下运行，输出 i = 10 i = 10
// 编译器干了什么：由于编译器发现两次从 i 读数据的代码之间的代码没有对 i 进行过操作，它会认为只需要从内存中读取一次就够了，自动把上次读的数据放在 b 中。而不是重新从 i 里面读。这样以来，如果 i 是一个寄存器变量或者表示一个端口数据就容易出错
```

**mutable**：

- 需要在 const 成员函数中修改一个成员变量的值，需要将这个成员变量修饰为 **mutable**。即用 mutable 修饰的成员变量不受 const 成员方法的限制

```c++
class A
{
public:
	static int a;
	mutable int b = 20; // 需要在 const 成员函数中改变一个成员变量的值
	void func() const {
		b++; 
	}
};
```

- 需要在 lambda 函数中使用改变了捕获参数的值，但又不想将这个改变传回源捕获参数，按值传递的话需要在函数体内**复制**一次，用**mutable**就不用

![image-20240611171903964](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744921.png) 

### auto decltype		

`auto `  要求变量**必须初始化**，也就是在定义变量的同时必须给它赋值，因为 `auto`  根据变量初始值来推导出变量类型，如果不初始化，变量的类型也就无法推导；`decltype` 则不要求，初始化与否都不影响变量的类型

- **推导规则不同**：`auto` 将变量的类型和初始值绑定在一起，而 `decltype` 将变量的类型和初始值分开；虽然 `auto` 的书写更加**简洁**，但 `decltype` 的使用更加**灵活**
- **应用场景不同**：`auto` 通常用于变量声明时，**简化类型定义**，特别是当类型名较长或复杂时
  `decltype` 常用于需要**精确类型匹配**的场景，如模板元编程、泛型编程中，以及定义依赖于表达式类型的变量
- **对 `const` 限定符的处理**：

```c++
// 在推导变量类型时，auto 和 decltype 对 cont 的处理是不一样的。decltype 会保留限定，而 auto 有可能会去掉限定
// a. 如果表达式的类型不是指针或者引用，auto 会把 cv 限定符直接抛弃，推导成 non-const 或者 non-volatile 类型。
// b. 如果表达式的类型是指针或者引用，auto 将保留 cv 限定符
const int n1 = 0;
auto n2 = n1; // n2 -> int
decltype(n1) n3; // n3 -> const int

const int *p1 = &n1;
auto p2 = p1; // p2 -> const int *
decltype(p1) p3; // pr -> const int *
```

- **对引用的处理**：

```c++
// decltype 会保留引用类型
// auto 会抛弃引用类型，直接推导出它的原始类型
int n = 0;
int &r1 = n;
auto r2 = r1; // r2 -> int
decltype(r1) r3; // r3 -> int&
```

- **总结**：
  a.  `auto` 书写格式比 `decltype` 简单，但推导规则复杂，有时候会改变表达式的原始类型；而 `decltype` 比较纯粹，一般会坚持保留原始表达式的任何类型
  b.  在实际开发中，如果明确知道使用的变量类型，那么使用 `auto`，减少代码量，增加可读性，其他场景使用 `decltype`

### noexcept

a. C++ 11中引入的一种新的异常说明符，用于明确指明一个函数或一个表达式是否会抛出异常

b 在函数的声明或定义后面加上 `noexcept` 关键字，可以告诉编译器这个函数不会抛出异常。如果这样的函数确实抛出类异常，C++ 运行时系统会调用 `std::terminate` 这将导致程序的立即终止

### explicit

**explicit 用于修饰单参构造函数，其作用是用来声明类构造函数是隐式调用的，而非隐式调用**

为什么是修饰单参构造函数呢？

因为无参构造函数和多参构造函数本身就是**显式调用**的，加上 explicit 关键字也没意义

```C++
class Student
{
public:
	Student(): m_age(0){
		std::cout << "无参构造函数, age = " << m_age << std::endl;
	}
	Student(int age): m_age(age){
		std::cout << "单参构造函数, age = " << m_age << std::endl;
	}
	~Student() = default;
private:
	int m_age;
};

int main()
{
	Student stu1;       // 无参构造函数, age = 0
	Student stu2(80);	// 单参构造函数, age = 80
	Student stu3 = 100; // 单参构造函数, age = 100 (隐式调用)
	// 在对象刚刚定义时, 即使你使用的是赋值操作符=, 也是会调用构造函数, 而不是重载的operator=运算符.

	return 0;
}
```

上面的例子中，`Student stu3 = 100;` **隐式调用**了单参构造函，这行代码没有错误，但把一个 int 类型的变量赋值给 Student 类型，存在**隐式转换**，埋下一颗雷，后续程序出错后难以排查。

所以，为了防止这种隐式转换可能带来的风险，需要把类的单参构造函数声明为显示调用的，即在构造函数前面加上关键字 **explicit**

```c++
class Student
{
public:
	Student(): m_age(0){
		std::cout << "无参构造函数, age = " << m_age << std::endl;
	}
	explicit Student(int age): m_age(age){
		std::cout << "单参构造函数, age = " << m_age << std::endl;
	}
	~Student() = default;
private:
	int m_age;
};

int main()
{
	Student stu1;       // 无参构造函数, age = 0
	Student stu2(80);	// 单参构造函数, age = 80
	Student stu3 = 100; // 编译时报错 error: conversion from ‘int’ to non-scalar type ‘Student’ requested

	return 0;
}
```

## 如何让对象只产生于栈/堆中

```C++
// C++ 创建对象的两种方式：

// 1.静态创建，由编译器为对象在栈空间中分配内存，然后在这片内存空间上调用构造函数创建一个栈对象。这种方式是直接调用类的构造函数
A a; 

// 2.动态创建，用new在堆空间上创建对象，具体过程是首先是执行operator new()函数，在堆空间上分配合适的内存；然后是调用构造函数构造对象，初始化这片内存空间。这种方式是间接的调用类的构造函数
A *p = new A;
```

### 如何只在栈上分配内存

a. 使用 `new`， 对象才会建立在堆上。故只需要禁用 `new` 运算符就可以实现类对象只能建立在栈上。

b. `new`是C++内置的运算符，我们不能改变，但可以利用 `new` 总是调用 `operator new()` 这一特性，将 `operator new()` 声明为私有即可

![image-20240612165808170](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744404.png) 

### 如何只在堆上分配内存

a. 当对象建立在栈上面时, 是由**编译器分配内存空间**的，当对象使用完以后，编译器会调用析构函数来释放对象所占的空间

b. 编译器在为类对象分配栈空间时, 会检查类的**析构函数的访问性**(其他非静态函数也会检查)，如果类的析构函数是**私有**的， 则编程器不会在栈空间上为类对象分配内存

c. 因此, 我们只需要**将析构函数设为私有，类对象就无法建立在栈上**

![image-20240612170526683](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744652.png) 

## 多态与虚函数

### 多态的定义

1.  **编译时多态（静态多态）**：也称为**重载多态**。在编译时根据函数或运算符的参数类型来确定调用的具体函数或操作。这种多态性在编译时就已经确定，因此也称为静态多态。C++ 中的函数重载(模板)就是一种编译时多态的表现
2.  **运行时多态（动态多态）**：也称为**覆盖多态**。在运行时根据对象的实际类型来确定调用的具体函数或方法。这种多态性是通过**虚函数**实现的，所以也称为动态多态。在基类中声明一个虚函数，在派生类中重新定义它，当通过**基类指针或引用调用该函数时，将根据对象的实际类型来调用相应的函数**

### 虚函数的定义与作用

在C++中，虚函数是为了实现**多态性**而设计的。通过将基类中的成员函数声明为**虚函数**，可以在派生类中**重新定义(重写)**该函数，并且在**运行时**根据对象的实际类型来调用相应的函数，从而实现多态

### 纯虚函数

声明在基类中的虚函数，在基类中没有定义，但要求所有的派生类必须提供自己的实现方法。纯虚函数是抽象基类的一部分，用于提供一个**接口**供派生类实现。

纯虚函数的主要目的是作为一个框架，引导和要求派生类进行某种实现，它们被设计为供派生类覆盖，并提供统一的接口。 （==**服务器项目中的业务接口类！**==）

### 虚函数的实现原理

虚函数的实现依赖于**虚函数表（vtable）和虚表指针（vptr）**。每个包含虚函数的类都有一个虚函数表（**one class one table**），其中存储了**该类的虚函数的地址**， 即虚函数表就是一个**虚函数指针数组**。同时，每个对象都包含一个指向虚函数表的指针，即虚表指针**（one instance one pointer）**当调用虚函数时，编译器会通过对象的虚指针找到对应的虚函数表，然后根据函数在虚函数表中的**偏移量**来调用相应的函数

- **如何找到虚函数？**
  1.  编译器会给每个虚函数指定一个在虚函数表中的**索引（偏移量）** 每个虚函数的偏移量在基类和派生类中相同，所以可以在编译时确定
  2.  编译器在编译期将虚函数的调用转化为 **`(*p->vptr[1])(p)`**, **() **内获取 **func1** 的地址，然后调用传参 **p**（表示 this 指针）
  3.  运行时根据指针 **p** 指向的是父类对象，那么虚表的内存布局就是父类的，指向子类那就是子类的

- **析构函数为什么要是虚函数？**
  1. 由于基类的多态性，基类指针可以指向派生类的对象，**将析构函数声明为虚函数**，删除该基类的指针，就会调用该指针指向的派生类析构函数，而==**派生类的析构函数又自动调用基类的析构函数**==，这样整个派生类的对象**完全被释放**。
  2. 如果析构函数不被声明成虚函数，则编译器实施**静态绑定**，在删除基类指针时，==**只会调用基类的析构函数而不调用派生类析构函数**==，这样就会造成派生类对象析构不安全，造成==**内存泄露**==。所以将析构函数声明为虚函数是十分必要的。在实现多态时，当用基类操作派生类，在析构时防止只析构基类而不析构派生类的状态发生，要将基类的析构函数声明为虚函数
- **构造函数可以是虚函数吗？** ---==**不可以**==
  1. 虚函数对应一个虚表指针，**虚表指针其实是存储在对象的内存空间的**。**如果构造函数是虚函数，就需要通过虚函数表中对应的虚函数指针（编译期间生成属于类）来调用**，可对象目前还没有实例化，也即是还没有内存空间，何来的虚指针，所以构造函数不能是虚函数
  2. 虚函数的作用在于通过父类的指针或者引用来调用它的成员函数的时候，能够根据动态类型来调用子类相应的成员函数。而构造函数是在创建对象时自动调用的，不可能通过父类的指针或者引用去调用，所以也不需要将其设置为虚函数

### 虚函数的内存布局

虚函数-> .text 									虚函数表->.rodata   			 虚函数指针->跟对象走

- **单继承内存模型**

  ```c++
  struct A
  {
      int ax; // 成员变量
      virtual void f0() {}
      virtual void f1() {}
  };
  
  struct B : public A
  {
      int bx; // 成员变量
      void f0() override {}; // 重写f0
  };
  ```

  ![image-20240613150949586](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549335.png) 

  ```c++
  // 如果类型 B 中出现了基类型A中没有的虚函数，新的虚函数将会被附加在虚函数表的最后，不会对与基类重合的部分造成影响。例如B中新增加了函数f2()，虚函数表变化如下：
  ```

  ![image-20240613151130318](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549336.png) 

- 多继承内存模型

  ```c++
  // 假设类型C同时继承了两个独立的基类A和B， 它们的定义关系如下：
  struct A
  {
      int ax;
      virtual void f0() {}
  };
  
  struct B
  {
      int bx;
      virtual void f1() {}
  };
  
  struct C : public A, public B
  {
      int cx;
      void f0() override {}
      void f1() override {}
  };
  ```

  ```C++
  // 与单链继承不同，由于A和B完全独立，它们的虚函数没有顺序关系，即f0和f1有着相同对虚表起始位置的偏移量，不可以顺序排布。
  // 并且A和B中的成员变量也是无关的，因此基类间也不具有包含关系
  // 这使得A和B在C中必须要处于两个不相交的区域中，同时需要有两个虚指针分别对它们虚函数进行索引。 其内存布局如下所示
  ```

  ![image-20240613151446359](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131549337.png) 

### 菱形继承

- **定义**：两个(多个)子类继承同一个父类而又有孙类同时继承这两个子类

  ```c++
  class A {
  public:
      int value;
  };
  
  class B : public A {};
  class C : public A {};
  class D : public B, public C {};
  ```

- **问题**：a. **数据二义性**，编译器不知道要访问的变量到底是哪个子类的  b.**数据冗余浪费内存空间**

- **解决方法**：子类**虚继承**基类，孙类再去继承子类时，就只会保留一份基类成员

  ```c++
  class A {
  public:
      int value;
  };
  
  class B : virtual public A {};
  class C : virtual public A {};
  class D : public B, public C {};
  ```

- **虚继承的底层实现**：虚基类的实现其实就是**产生虚基类表指针 vbptr 与虚基类表 vbtable**。编译器 gcc 的做法是将虚基类放在对象末尾, 在虚表中添加一项, 记录**基类对象在对象中的偏移**, 从而获得其地址

### 没有虚函数如何实现动态多态

- 在基类中添加一个成员变量来标记对象的类型(标记可以用来区分派生类)，然后用条件语句(`if...else...  switch case`)根据这个标记来调用对应的函数

## 左值右值

### 值语义：

- **GC语言**：带有垃圾回收（Garbage Collection, GC）机制的编程语言。垃圾回收是一种自动内存管理的技术，用于在程序运行时自动回收不再使用的内存，以防止内存泄漏和优化内存使用（Java、Python、Go）。大部分变量都是**引用语义**，内存管理交给**GC**
- **C++**：通过**值语义**可以方便直观地控制对象生命周期，让 RAII 用起来更自然(构造时初始化资源，析构函数中释放资源)
- **引用**：即别名，声明时必须初始化其引用哪个对象，通过引用来修改变量值

### 左值：**可以**在等号左边，能够取地址，具名

```c++
int a = 10; 		  // 变量名 
int &a = func(); 	  // 返回左值引用的函数调用
++i = 100; --i = 100; // 前置自增/自减 可以理解为：i = i - 1 ; return i;
(i += 10) = 1000; 	  // 赋值运算或复合赋值运算
(*p) = 100; 		  // 解引用
// 右值引用本身可以是左值，也可以是右值，但是它只能被赋右值,即具名的右值引用被当成左值，匿名的(std::move(a))则被当为右值
```

### 右值：**只能**在等号右边，不能取地址，不具名

- **纯右值**：

```c++
int a = 10; // 字面值，这个10就是右值
char* p = "Hello World!"; // 注意这里 "Hello World!" 是左值，存在于常量区，可以取地址
int a = func(); // 返回非引用类型的函数调用
i ++ , i -- ; //  后置自增、自减 可以理解为：int j = i; i = i - 1 ; return j;
a + b; a && b; a > b; // 算数表达式、逻辑表达式、比较表达式
```

- **将亡值**：

```c++
// C++ 11 所引入的与右值引用(移动语义)相关的值类型
// 将亡值用来触发移动构造或移动拷贝，并进行资源转移(避免深拷贝、提高效率)，注意是转移堆上的资源，栈上的资源生命周期是固定的
```

### 引用

- **左值引用**：对左值的引用，可以避免对象拷贝，比如函数传参、函数返回值、一个对象初始化另一对象(int& a = b;) **这三个就是会出现拷贝的场景**

```c++
const int& a = 10; // const 左值引用可以指向右值，但存在不能修改的局限
```

- **右值引用**：对右值的引用

```c++
MyClass obj1(10);            	 // 调用带参数构造函数
MyClass obj2 = std::move(obj1);  // 调用移动构造函数(不涉及到深拷贝)
// 注意：此时 obj1 的 data 指针被置为空，obj1 不再拥有原有的资源(被转移了)
// 右值引用可以通过 std::move(v) 可以指向左值
// 我的理解：就是将 v 强转成右值引用类型，然后就可以调用到移动构造函数或者移动赋值运算符来避免深拷贝
```

- **右值引用的作用**：==主要目的就是提高程序运行效率==
  
  1. 实现**移动语义**：对象赋值时，触发移动构造或移动赋值避免**深拷贝**导致资源的重新分配, ==**所有权转移**==(浅拷贝**原对象的指向资源的指针，赋给新的对象成员**)
  2. 有了移动语义就可以触发移动构造和移动赋值(**传右值引用就会调用移动构造/赋值而非拷贝构造/赋值**)
  3. `std::unique_ptr`：其中删l除了类拷贝构造和赋值运算符重载，但实现了移动构造和移动赋值以及支持函数返回值(还是可以确保只有一个管理对象)，**move-only** 详见上文**智能指针**
  4. 实现完美转发：函数模板可以将自己的参数完美地转发给内部调用地其他函数，让代码保持简洁。不仅能准确地转发参数的值，还能保证被转发的参数的左右值属性不变。借用万能引用，通过引用的方式接收左右属性的值, 虽然名字含义是转发，但他并不会做转发，同样也是做**类型转换**
  5. **因此，可移动对象在<需要拷贝且被拷贝者之后不再被需要>的场景，建议使用**`std::move`**触发移动语义，提升性能**
  
  ==**std::move 是为了将左值转为右值引用，从而可以触发移动构造和移动赋值来转移对象的所有权，而不是移动对象**==

```c++
void func(int &n){
	printf("lvalue = %d\n", n);
}

void func(int &&n){
	printf("rvalue = %d\n", n);
}

template<typename T>
void revoke(T &&t){ // 万能引用
	// 参数为左值或左值引用, T&& 将转化为 int &
	// 参数为右值或右值引用, T&& 将转化为 int && 
	func(std:forward(T)(t));
}
```

## 线程同步(及其API)

### 原子操作

- `a ++ ;` 不是原子的：

```c++
// 1. 将变量a对应的内存值搬运到某个寄存器（如eax）中  2.然后将该寄存器中的值自增1  3.再将该寄存器中的值搬运回a代表的内存中
// 以上每一步都有可能发生操作系统的线程调度与切换，某个线程可能执行到其中一步就被剥夺时间片，故这种非原子操作就存在线程安全问题
mov eax, dword ptr [a]  
inc eax
mov dword ptr [a], eax
```

- C++ 11 中的整型原子变量

```c++
// 支持：bool、char、short、long...
std::atomic<int> a(0); // 等价于：std::atomic<int> a; a = 0;
```

- C++ 11 中的整型原子方法

| 方法名           | 方法说明                                                     |
| ---------------- | ------------------------------------------------------------ |
| operator=        | 存储值于原子对象                                             |
| store            | 原子地以非原子对象替换原子对象的值 `std::atomic_store(&a, 100);` |
| load             | 原子地获得原子对象的值 `std::atomic<int> a(100);  auto c = std::atomic_load(&a);` |
| exchange         | 原子地替换原子对象的值并获得它先前持有的值 `auto b = std::atomic_exchange(&a, 10);` |
| fetch_add        | 原子地将参数加到存储于原子对象的值，并返回先前保有的值 `auto b = std::atomic_fetch_add(&a, 10);` |
| fetch_sub        | 原子地从存储于原子对象的值减去参数，并获得先前保有的值 `auto b = std::atomic_fetch_sub(&a, 10);` |
| operator++ / --  | 令原子值增加或减少一                                         |
| operator += / -= | 原子地与右边的参数进行加、减运算并将结果存储在原子对象中     |

### 信号量

- **Linux 下的 API**

```c++
sem_t  mysemaphore; // 声明一个信号量
// _1:信号量对象地址 _2:是否可以共享，0->只能在同一个进程多个线程之间共享 _3:信号量初始状态下资源的数量
int sem_init(sem_t* sem, int pshared, unsigned int value); // 初始化一个信号量
int sem_destroy(sem_t* sem); // 销毁一个信号量
int sem_post(sem_t* sem); // 将信号量的资源计数递增1，并解锁该信号量对象，这样其他由于使用sem_wait被阻塞的线程会被唤醒 ( V 操作)
int sem_wait(sem_t* sem); // 若前信号量资源计数为0，sem_wait 会阻塞调用线程；直到资源计数大于0时被唤醒，唤醒后将资源计数递减1，然后立即返回 (P 操作)
int sem_trywait(sem_t* sem); // 不阻塞，立即返回，错误码errno被设置成EAGAIN
int sem_timedwait(sem_t* sem, const struct timespec* abs_timeout); // 带有等待时间的版本
```

### 自旋锁

```c++
// 原子变量实现自旋锁
class SpinLock { 
private:
    std::atomic_flag flag = ATOMIC_FLAG_INIT; // 初始化为未设置 false

public:
    SpinLock() = default;

    void lock() {
		// 如果锁已被占用(即 flag 已经被设置为 true)，自旋等待
        // 尝试设置 flag 为 true,并发挥设置前的值，所以如果设置前是 false 则不用忙等(循环)
        while (flag.test_and_set(std::memory_order_acquire)) {  } 
    }
    void unlock() {
        flag.clear(std::memory_order_release); // 将 flag 清除（即设置为 false)
    }
};

int i = 0;     // 临界区资源
SpinLock lock; // 自旋锁

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		lock.lock();
		i ++ ;
		lock.unlock();
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		lock.lock();
		i -- ;
		lock.unlock();
	} 
}

int main()
{
	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // always: 0

	return 0;	
}
```

### 互斥锁

- **Linux 下的 API**

```c++
pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; // 声明一个互斥体 且不用 init()
// _1：互斥体对象的指针 _2:需要设置的互斥体属性，如果填 NULL 默认使用普通锁，也不用创建互斥体属性对象
int pthread_mutex_init(pthread_mutex_t* restrict mutex, const pthread_mutexattr_t* restrict attr); // 初始化互斥体 
int pthread_mutex_destroy(pthread_mutex_t* mutex); // 销毁互斥体

int pthread_mutex_lock(pthread_mutex_t* mutex);    // 加锁互斥体
int pthread_mutex_trylock(pthread_mutex_t* mutex); // 非阻塞加锁
int pthread_mutex_unlock(pthread_mutex_t* mutex);  // 解锁互斥体

// 互斥体的属性
pthread_mutexattr_t mymutex_attr; // 声明一个互斥体属性
int pthread_mutexattr_init(pthread_mutexattr_t* attr); 				// 初始化互斥体属性
int pthread_mutexattr_destroy(pthread_mutexattr_t* attr); 			// 销毁互斥体属性
int pthread_mutexattr_settype(pthread_mutexattr_t* attr, int type); // 设置互斥体属性
// 属性的类型：
PTHREAD_MUTEX_NORMAL // 普通锁，其他线程再次加锁时会阻塞在 pthread_mutex_lock 调用处，直到对互斥体加锁的线程释放了锁
PTHREAD_MUTEX_ERRORCHECK // 检错锁，其他线程再次加锁时，pthread_mutex_lock会返回EDEADLK
PTHREAD_MUTEX_RECURSIVE // 可重入锁(即递归锁)，允许同一个线程对其持有的互斥体重复加锁，每成功调用pthread_mutex_lock一次，该互斥体对象的锁引用计数就会增加1，相反，每成功调用pthread_mutex_unlock一次，锁引用计数就会减少1。当锁引用计数值为0时，允许其他线程获得该锁，否则当其他线程调用pthread_mutex_lock尝试获取锁时，会阻塞在pthread_mutex_lock调用
```

```c++
int i = 0; // 临界区资源
pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; // 初始化互斥体

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		pthread_mutex_lock(&mymutex);
		i ++ ;
		pthread_mutex_unlock(&mymutex);
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		pthread_mutex_lock(&mymutex);
		i -- ;
		pthread_mutex_unlock(&mymutex);
	} 
}

int main()
{
	// pthread_mutex_init(&mymutex, NULL); // 初始化时用了宏 不用再 init()

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // always: 0

	// pthread_mutex_destroy(&mymutex); // 使用 PTHREAD_MUTEX_INITIALIZER 初始化的互斥体无须销毁
	return 0;	
}
```

- **C++ 11 下的 API**

| **互斥体**            | **版本** | **作用**                                         |
| --------------------- | -------- | ------------------------------------------------ |
| mutex                 | C++11    | 最基本的互斥量                                   |
| timed_mutex           | C++11    | 有超时机制的互斥量                               |
| recursive_mutex       | C++11    | 可重入的互斥量(**递归锁**)                       |
| recursive_timed_mutex | C++11    | 结合 timed_mutex 和 recursive_mutex 特点的互斥量 |

**均提供了加锁（lock）、尝试加锁（trylock）和解锁（unlock）的方法**

```c++
int i = 0; // 临界区资源
std::mutex mymutex;

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		mymutex.lock();
		i ++ ;
		mymutex.unlock();
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		mymutex.lock();
		i -- ;
		mymutex.unlock();
	} 
}

int main()
{
	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // always: 0

	return 0;	
}
```

### 读写锁

-  **Linux 下的 API**

```c++
pthread_rwlock_t myrwlock = PTHREAD_RWLOCK_INITIALIZER; // 声明一个读写锁 且不用 init()
// _1：读写锁的指针 _2:需要设置的读写锁属性，如果填 NULL 默认使用普通锁，也不用创建互斥体属性对象
int pthread_rwlock_init(pthread_rwlock_t* rwlock, const pthread_rwlockattr_t* attr);
int pthread_rwlock_destroy(pthread_rwlock_t* rwlock); // 销毁读写锁

// 3 个请求读锁的系统 API 接口 --- [读锁共享]
int pthread_rwlock_rdlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_tryrdlock(pthread_rwlock_t* rwlock); // 非阻塞加锁
int pthread_rwlock_timedrdlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);

// 3 个请求写锁的系统 API 接口 --- [写锁独占]
int pthread_rwlock_wrlock(pthread_rwlock_t* rwlock);
int pthread_rwlock_trywrlock(pthread_rwlock_t* rwlock); // 非阻塞加锁
int pthread_rwlock_timedwrlock(pthread_rwlock_t* rwlock, const struct timespec* abstime);

// 无论读锁还是写锁，锁的释放都是一个接口
int pthread_rwlock_unlock (pthread_rwlock_t* rwlock);

// 读写锁的属性
pthread_rwlockattr_t myrwlock_attr; // 声明一个读写锁属性
int pthread_rwlockattr_init(pthread_mutexattr_t* attr);    				 // 初始化读写锁属性
int pthread_rwlockattr_destroy(pthread_mutexattr_t* attr); 		         // 销毁读写锁属性
int pthread_rwlockattr_setkind_np(pthread_rwlockattr_t* attr, int pref); // 设置读写锁属性
// 属性的类型：
enum
{
    PTHREAD_RWLOCK_PREFER_READER_NP,  //读者优先(即同时请求读锁和写锁时，请求读锁的线程优先获得锁)
    PTHREAD_RWLOCK_PREFER_WRITER_NP,  //不要被名字所迷惑，实际也是读者优先，不过写者偏向
    PTHREAD_RWLOCK_PREFER_WRITER_NONRECURSIVE_NP, //写者优先(即同时请求读锁和写锁时，请求写锁的线程优先获得锁)	 			
    PTHREAD_RWLOCK_DEFAULT_NP = PTHREAD_RWLOCK_PREFER_READER_NP // 默认采用读者优先
};
```

| **锁当前状态/其他线程请求锁类型** | **请求读锁** | **请求写锁** |
| --------------------------------- | ------------ | ------------ |
| 无锁                              | 通过         | 通过         |
| 已经获得读锁                      | 通过         | 阻止         |
| 已经获得写锁                      | 阻止         | 阻止         |

```c++
int i = 0; // 临界区资源
pthread_rwlock_t myrwlock = PTHREAD_RWLOCK_INITIALIZER; // 初始读写锁

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		pthread_rwlock_wrlock(&myrwlock); // 写独占，如果这里换请求读锁就不线程安全了
		i ++ ;
		pthread_rwlock_unlock(&myrwlock);
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		pthread_rwlock_wrlock(&myrwlock); // 写独占，如果这里换请求读锁就不线程安全了
		i -- ;
		pthread_rwlock_unlock(&myrwlock);
	} 
}

int main()
{
	// pthread_mutex_init(&myrwlock, NULL); // 初始化时用了宏 不用再 init()

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // 请求写锁 -> always: 0  请求读锁 -> sometimes:-11898 sometimes:11435

	// pthread_mutex_destroy(&myrwlock); // 使用 PTHREAD_RWLOCK_INITIALIZER 初始化的读写锁无须销毁
	return 0;	
}
```

- **C++ 11 下的 API**

| 互斥量             | 版本  | 作用                 |
| ------------------ | ----- | -------------------- |
| shared_timed_mutex | C++14 | 具有超时机制的读写锁 |
| shared_mutex       | C++17 | 读写锁               |

**提供了加写锁（lock）、解写锁（unlock）、加读锁（lock_shared）、解读锁（unlock_shared） 的方法**

```c++
int i = 0; // 临界区资源
std::shared_mutex myrwlock; // 创建读写锁

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		myrwlock.lock(); // 写独占，如果这里换请求读锁就不线程安全了
		i ++ ;
		myrwlock.unlock(); 
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		myrwlock.lock(); // 写独占，如果这里换请求读锁就不线程安全了
		i -- ;
		myrwlock.unlock(); 
	} 
}

int main()
{
	// pthread_mutex_init(&myrwlock, NULL); // 初始化时用了宏 不用再 init()

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // 请求写锁 -> always: 0  请求读锁 -> sometimes:-11898 sometimes:11435

	return 0;	
}
```

### RAII 管理锁

为了避免死锁， **`std::mutex.lock()`** 和 **`std::mutex::unlock()`** 方法需要成对使用，但是如上文介绍的如果一个函数中有很多出口，而互斥体对象又是需要在整个函数作用域保护的资源，那么在编码时因为忘记在某个出口处调用 **`std::mutex.unlock()`** 而造成死锁，上文中推荐使用利用 RAII 技术封装这两个接口，其实 C++ 11 标准也想到了整个问题，因为已经为我们提供了如下封装：

| 互斥量管理  | 版本  | 作用                   |
| ----------- | ----- | ---------------------- |
| lock_guard  | C++11 | 基于作用域的互斥量管理 |
| unique_lock | C++11 | 更加灵活的互斥量管理   |
| shared_lock | C++14 | 共享互斥量的管理       |
| scope_lock  | C++17 | 多互斥量避免死锁的管理 |

```c++
// 以 std::lock_guard 为例
void func()
{
	std::lock_guard<std::mutex> guard(mymutex);
	//在这里放被保护的资源操作
}
// mymutex 的类型是 std::mutex，在 guard 对象的构造函数中，会自动调用 mymutex.lock() 方法加锁，当该函数出了作用域后，调用 guard 对象时析构函数时会自动调用 mymutex.unlock() 方法解锁

// std::unique_lock 管理写锁
// std::shared_lock 管理读锁
```

```c++
int i = 0; // 临界区资源
std::mutex mymutex;

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		std::lock_guard<std::mutex> guard(mymutex); // RAII 封装锁
		i ++ ;
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		std::lock_guard<std::mutex> guard(mymutex); // RAII 封装锁
		i -- ;
	} 
}

int main()
{
	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // always: 0

	return 0;	
}
```

```C++
int i = 0; // 临界区资源
std::shared_mutex myrwlock; // 创建读写锁

void test()
{
	for (int j = 0; j < 100000; j ++ )
	{
		std::unique_lock<std::shared_mutex> lock(myrwlock); // RAII 封装写锁
		i ++ ;
	} 
}

void test2()
{
	for (int j = 0; j < 100000; j ++ )
	{
		std::unique_lock<std::shared_mutex> lock(myrwlock); // RAII 封装写锁
		i -- ;
	} 
}

int main()
{
	// pthread_mutex_init(&myrwlock, NULL); // 初始化时用了宏 不用再 init()

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	std::cout << i << std::endl; // 请求写锁 -> always: 0  请求读锁 -> sometimes:-11898 sometimes:11435

	return 0;	
}
```

### 条件变量

**条件变量需要和互斥锁配合使用**，因为释放锁和等待唤醒必须是位于同一个原子操作中，才能确保`cond_wait`唤醒之前不会有其他线程获得这个互斥体对象

- **Linux API**

```c++
pthread_cond_t cond = PTHREAD_COND_INITIALIZER; // 声明一个条件变量，且不用 init
int pthread_cond_init(pthread_cond_t* cond, const pthread_condattr_t* attr); // 创建条件变量
int pthread_cond_destroy(pthread_cond_t* cond); // 销毁条件变量

// 等待条件变量
int pthread_cond_wait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex); 
int pthread_cond_timedwait(pthread_cond_t* restrict cond, pthread_mutex_t* restrict mutex, const struct timespec* restrict abstime); // 非阻塞

// 唤醒等待的线程
int pthread_cond_signal(pthread_cond_t* cond);  // 一次唤醒一个线程，如果有多个线程等待，具体哪个线程被唤醒是不确定的（可以认为是随机的）
int pthread_cond_broadcast(pthread_cond_t* cond); // 可以同时唤醒所有调用pthread_cond_wait等待的线程    
```

```c++
int i = 0; // 临界区资源
pthread_cond_t mycond = PTHREAD_COND_INITIALIZER;    // 初始化条件变量
pthread_mutex_t mymutex = PTHREAD_MUTEX_INITIALIZER; // 初始化互斥锁

void test()
{
	while(true)  // 生产者 负责给 i ++ 
	{
		pthread_mutex_lock(&mymutex);
		i ++ ;
		std::cout << "I am thread 1 "<< i << std::endl; // always: 0
		pthread_mutex_unlock(&mymutex);
		pthread_cond_signal(&mycond);
		sleep(1);
	} 
}

void test2()
{
	while (true) // 消费者 负责给 i -- 
	{	
		// 当pthread_cond_wait函数阻塞时，它会释放其绑定的互斥体，并阻塞线程，因此在调用该函数前应该对互斥体有个加锁操作
		pthread_mutex_lock(&mymutex); 
		while (i < 10) // 小于10时，消费者拿到锁也会立即释放并等待
		{
			// 如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行(即，解锁等待一起)。
			// 当发生变化后，条件合适，pthread_cond_wait将直接获得锁
			// 解锁和等待必须是同一个原子操作，详见笔记
			pthread_cond_wait(&mycond, &mymutex);	
		}
		i -- ;
		std::cout << "I am thread2 "<< i << std::endl; 
		// 当收到条件信号时， pthread_cond_wait会返回并对其绑定的互斥体进行加锁，因此在其下面一定有个对互斥体进行解锁的操作
		pthread_mutex_unlock(&mymutex);
	}
	
}

int main()
{
	// pthread_mutex_init(&mymutex, NULL); // 初始化时用了宏 不用再 init()
	// pthread_cond_init(&mymutex, NULL); // 初始化时用了宏 不用再 init()

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	// pthread_mutex_destroy(&mymutex); // 使用 PTHREAD_MUTEX_INITIALIZER 初始化的互斥体无须销毁
	// pthread_cond_destroy(&mymutex); // 使用 PTHREAD_COND_INITIALIZER 初始化的条件变量无须销毁
	return 0;	
}
```

- **C++ 11 API**

C++ 11 提供了 **std::condition_variable** 这个类代表条件变量，与 Linux 系统原生的条件变量一样，同时提供了等待条件变量满足的 **wait** 系列方法（wait、wait_for、wait_until 方法），发送条件信号使用 **notify** 方法（**notify_one** 和 **notify_all** 方法），当然使用 **std::condition_variable** 对象时需要绑定一个 **std::unique_lock** 或 **std::lock_guard** 对象

```c++
int i = 0; // 临界区资源
std::condition_variable mycv;    // 条件变量
std::mutex mymutex; // 互斥锁

void test()
{
	while(true)  // 生产者 负责给 i ++ 
	{
		{
			std::unique_lock<std::mutex> guard(mymutex);
			i ++ ;
			std::cout << "I am thread 1 "<< i << std::endl; // always: 0
			// RAII 封装，无需解锁，但是需要让他离开作用域自动释放
		}
		mycv.notify_one();
		sleep(1);	
	} 
	
}

void test2()
{
	while (true) // 消费者 负责给 i -- 
	{	
		// 当pthread_cond_wait函数阻塞时，它会释放其绑定的互斥体，并阻塞线程，因此在调用该函数前应该对互斥体有个加锁操作
		std::unique_lock<std::mutex> guard(mymutex);
		while (i < 10) // 小于10时，消费者拿到锁也会立即释放并等待
		{
			// 如果获得了互斥锁，但是条件不合适的话，pthread_cond_wait会释放锁，不往下执行(即，解锁等待一起)。
			// 当发生变化后，条件合适，pthread_cond_wait将直接获得锁
			// 解锁和等待必须是同一个原子操作，详见笔记
			mycv.wait(guard);
		}
		i -- ;
		std::cout << "I am thread2 "<< i << std::endl; 
		// RAII 封装，无需解锁
	}
	
}

int main()
{

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	return 0;	
}
```

### 线程局部存储

线程局部存储（**Thread Local Storage，TLS**）是一种编程技术，用于为**每个线程分配独立的存储空间**，以便线程能够独立地存取和修改数据，而不会与其他线程干扰。这**对于并发编程非常有用，因为它允许线程安全地处理数据**，而无需复杂的锁机制来防止数据竞争（这个变量在它所在的线程内是全局可访问的，但是不能被其他线程访问到，这样就保持了数据的线程独立性）

- **特点**：

1. **每个线程有自己独立的数据副本**：每个线程在访问线程局部存储中的变量时，访问的是自己独立的副本，而不是共享的全局变量
2. **数据独立性**：由于每个线程都有自己的数据副本，线程之间不会相互干扰，从而避免了数据竞争
3. **自动管理生命周期**：线程局部存储中的变量生命周期与线程生命周期相同，当线程结束时，线程局部存储中的变量也会被自动释放

- **API**： `__thread` **Linux**               `thread_local`   **C++ 11**

```c++
// 线程局部存储变量，理解为每个线程独立一个，不同线程间互不干扰
__thread int g_mydata = 99;     // Linux
thread_local int g_mydata = 99; // C++ 11

void test()
{
	while(true) 
	{
		g_mydata ++ ; // 这里是线程 1 的 g_mydata
		std::cout << "I am thread 1 "<< g_mydata << std::endl; // 99 100 101...
		sleep(1);
	} 		
}

void test2()
{
	while(true) 
	{
		// 这里是线程 2 的 g_mydata
		std::cout << "I am thread 2 "<< g_mydata << std::endl; // always:99
		sleep(1);
	} 
}

int main()
{

	std::thread t1(test);
	std::thread t2(test2);

	t1.join();
	t2.join();

	return 0;	
}
```

## 编译原理

### 基本过程

| 过程      | 文件                          | 操作                                                         |
| --------- | ----------------------------- | ------------------------------------------------------------ |
| 1. 预处理 | `.i` (文本)                   | 主要用于处理 `#` 开头的代码行，比如对宏做展开，对include的文件做展开，条件编译选项判断，清理注释等<br />`gcc -E foo1.c -o foo1.i` |
| 2. 编译   | `.s` (文本)                   | 使用预处理的输出结果作为输入，进行 **语法分析 词法分析 语义分析 源代码优化 目标代码生成和优化**以后，生成文本格式的平台相关的**汇编代码**(assembly code)<br />`gcc -S foo1.i -o foo1.s` |
| 3. 汇编   | `.o` 可重定位目标程序(二进制) | 将上一步的汇编代码转换成二进制的机器码，称为object code。产生的文件叫做**目标文件**，是**二进制格式**<br />`gcc -c foo1.s -o foo1.o` |
| 4. 链接   | 可执行目标程序(二进制)        | 将多个可重定位文件进行**空间和地址重分配，符号解析和重定位**最终组成一个可执行目标文件<br />`gcc -o foobar foo3.c foo4.c` |

### 目标文件

Linux下的==目标文件==为**`ELF`**格式，主要有三种类型:

a. **可重定位目标文件 .o**：汇编阶段生成 包含**二进制和代码**，可在链接阶段和其它可重定位目标文件链接，生成可执行目标文件

b. **可执行目标文件**: 最终链接生成的文件 可加载到内存执行

c. **共享目标文件 .so**：特殊的目标文件 可以在**运行时被动态链接**加载到内存运行(见下文**动态链接**)

虽然细分了具体类型，但是**文件格式**基本类似都是**ELF格式(Executable Linkable Format，可执行可链接格式)**，主要是**`ELF`头 + 若干段**

![image-20240613121025163](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131211751.png)  ![image-20240613121341346](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448747.png) 

### 链接

**(1) 空间和地址重分配**：本例中`foo1.o`和`foo2.o`中均含有`.text .data`等对应段，链接时会将多个可重定位文件的相似段进行**合并**，如多个`.text`段合并为一个`.text`段, 示意图如下:

![img](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448790.jpeg)

**（2）符号解析和重定位**：在空间和地址分配以后，我们确定了可执行文件各个段以及各个符号的具体**虚拟地址**。接下来需要原来可重定位文件中的**符号**进行解析以及重定位； **强符号**:**函数和已经初始化（包括零值）的全局变量** 如`foo1.c`中的`x y sum main`等    **弱符号:未初始化的全局变量**

### 静态库链接

==**什么是静态库？**==
**可重定位目标文件(.o)**以一种特定的方式**打包**成一个单独的文件，并且在链接生成可执行文件时，从这个单独的文件中“**拷贝**”它自己需要的内容到最终的可执行文件中。**这个单独的文件，称为静态库**。Linux中通常以 **.a(archive)** 为后缀，存档文件(**.a**)是一组**可重定位目标文件的集合**，并且在文件头部记录了每个可重定位目标文件的**大小和位置**信息

```shell
 gcc -static -o main main.o -lm
```

在上面链接过程中，就会用到系统中的静态库 **libm.a**

特别注意 **`-lm`** 必须放在后面，因为链接器是**从左向右**扫描，遇到未解析的符号记住，在静态库中找到未解析的符号就提取

**`static`** 参数，告诉链接器应该使用**静态链接**，**`-lm`** 参数表明链接 **libm.a** 这个库（类似的，如果要链接 **libxxx.a** ,使用 **`-lxxx`** 即可）。由于 **main.c** 中使用了**libm.a** 中的 `exp` 函数，因此链接时，会将 **libm.a** 中需要的代码**“拷贝”**到最终的可执行文件 **main** 中。由于最终生成的可执行文件中已经包含了 `exp` 相关的二进制代码，因此这个可执行文件在一个没有 **libm.a** 的 Linux 系统中也能正常运行

![image-20240613124723322](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448748.png)  

### 动态库链接

==**什么是动态库？**==
动态库和静态库类似，但是它并不在链接时将需要的二进制代码都“拷贝”到可执行文件中，而是仅仅“拷贝”一些**重定位和符号表**信息，这些信息可以在**程序运行时**完成真正的链接过程。Linux中通常以 **.so（shared object）**作为后缀

==**为什么要有动态库？**==

1. **在静态链接时 当多份可执行文件链接同一个重定位文件时，均拥有一份重定位文件的副本，对磁盘以及内存产生极大浪费**
2. **静态库文件发生变更时，需要重新编译和链接**

==**Linux实现动态共享库方式？**==

1. 每个文件系统中，每个库只有**唯一**的一个 **.so** 文件 使用这个库的程序可以**共享 .so** 文件的代码和只读数据 而非将 **.so **文件复制一份
2. 可执行文件启动时，先将控制权交给**动态链接器**，动态链接器会**将可执行文件依赖的共享库文件加载进内存**（也可延迟加载），等共享库加载完毕后将控制权交给可执行文件的入口函数，开始运行 

在静态链接时，可执行文件中的段是由每个可重定位文件的段**拼接**而来的。在动态链接时，共享库在**运行时进行加载**，加载时 Linux 系统会按照**内存映射文件的形式将共享库文件整个映射到内存中堆栈之间的某个起始地址（一般为0x40000000**），并不会进行段的拆分和合并工作，示意图如下。

![img](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131448749.jpeg)

### 静态链接与动态链接的区别

| 区别                    | 静态链接                                                     | 动态链接                                                     |
| ----------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 1. 可执行文件大小不一样 | 将需要用到的**代码**从二进制文件中“拷贝”了一份               | 仅仅是复制了一些**重定位和符号表**信息                       |
| 2. 占用磁盘大小不一样   | 如果有多个可执行文件，那么静态库中的同一个函数的代码就会被**复制多份** | 动态库**只有一份**                                           |
| 3. 扩展性与兼容性不一样 | 如果静态库中某个函数的实现变了，那么可执行文件必须**重新编译**(更具体点是**链接**) | 只需要更新动态库本身即可，不需要重新编译可执行文件<br />**请注意：以上说的是动态库中的函数实现改变了，使用该库的程序无需重新编译链接，然而，如果动态库中的==函数接口改变了，比如修改或增加了函数签名==，那么依然需要重新编译链接** |
| 4. 依赖不一样           | 静态链接的可执行文件不需要依赖其他的内容即可运行             | 动态链接的可执行文件必须**依赖动态库的存在**                 |
| 5. 复杂性不一样         | easy                                                         | 运行时确定地址、多个进程如何共享、动态库版本管理...          |
| 6. 加载速度不一样       | 静态库在链接时就和可执行文件在一块了，故静态链接更快         | 选择静态库还是动态库是**时间和空间**的考量，但是通常来说，牺牲这点性能来换取程序在空间上的节省和部署的灵活性时值得的。再加上**局部性原理**，牺牲的性能并不多 |

### 静态库的制作与链接

- **Linux 下**

```shell
// 将源文件编译为目标文件
gcc -c foo.c -o foo.o
gcc -c bar.c -o bar.o
// 使用 ar 命令将目标文件打包成静态库
ar rcs libmylib.a foo.o bar.o

// 链接静态库
gcc -static -o main main.o -lmylib
```

- **CMake**

```cmake
# 将源文件列表化
set(SOURCES
	foo.c
	bar.c
)
# 添加静态库目标
add_library(mylib STATIC ${SOURCES})

# 链接静态库
link_libraries(mylib)
```

### 动态库的制作与链接

- **Linux 下**

```shell
// 将源文件编译为目标文件
gcc -c foo.c -o foo.o
gcc -c bar.c -o bar.o
// 将目标文件打包成动态库
gcc -shared foo.o bar.o -o libmylib.so

// 链接动态库
gcc -o main main.c -L. -lmylib
```

- CMake

```cmake
# 将源文件列表化
set(SOURCES
	foo.c
	bar.c
)
# 添加静态库目标
add_library(mylib SHARED ${SOURCES})

# 链接动态库 必须写在生成可执行文件的命令后面
# 添加并指定最终生成的可执行程序名
add_executable(app ${SRC_LIST})
# 指定可执行程序要链接的动态库名字
target_link_libraries(app mylib)
```



## TODO 模板

模板函数不能是虚函数，C++中模板的实例化发生在编译时，而虚函数的选择是在运行时进行的，这两者机制是冲突的

模板函数的实现:通过模板机制，在编译时实例化，编译器会为每一个不同的模板参数类型生成一个对应的函数

故模板也是**静态多态**：可以处理任何数据类型，只要数据类型支持模板函数中使用到的所有操作

## TODO 内存对齐

## 内存拷贝函数 

==**总结**==：内存拷贝过程中，需要考虑的两个问题点：**1. 目标缓冲区溢出问题  2.源内存和目标内存之间的内存重叠问题**

### strcpy

```c++
// 将src指向的源字符串复制到dest指向的目标字符串存储位置，空终止符也会被复制，拷贝到一个空终止符`\0`就结束拷贝
char* strcpy(char* dest, const char* src)  // _1:目标字符串的内存地址 _2：源字符串的内存地址 return: char*
```

- **注意点：**

1. **缓冲区溢出**：`strcpy`不会检查目标缓冲区的大小，如果 dest 的空间不足以容纳 src 的内容，会导致**缓冲区溢出，从而引发未定义行为**。为了避免这种问题，推荐使用更安全的函数
2. **内存重叠**：src 和 dest 所指的内存区域**不能重叠**

- **代码实现**：

```c++
char *strcpy(char* strDest, const char* strSrc) // 源字符串要 const 修饰，避免在函数内部被修改
{
    if (strDest == NULL || strSrc == NULL) return NULL; // 函数入口要检查字符串指针和目标字符串指针是否有为空的，否则会产生不可预料的错误
    char *address = strDest; // 定义返回值，因为拷贝过程中会修改 stdDest，不能直接用于返回
    while((*strDest++ = *strSrc++) != '\0'); // 空终止符需要拷贝，且拷贝到一个后就退出循环
    return address;
}
```

### strncpy

```c++
// 拷贝src字符串的前 n 个字符至 dest， 与 strcpy 的区别在于可以指定长度
char *strncpy(char *dest, const char *src, size_t n); // _1:目标字符串的内存地址 _2：源字符串的内存地址 _3:拷贝的长度 return: char*
```

- **注意点：**

1. 如果 src 长度小于 `n`，则 dest 中剩余的空间将用空字符 `'\0'` 填充。如果 src 长度大于或等于 `n`，则 dest 将**不会以空字符结尾**
2. **缓冲区溢出**：如果目标字符串长度不足 `n`，会引发未定义行为。因此，目标字符串**必须有足够的空间**来容纳 `n` 个字符
3. **内存重叠**: src 和 dest 所指的内存区域**不能重叠**

- **代码实现：**

```c++
char *strncpy(char* strDest, const char* strSrc, size_t n)
{
    assert( (strDest != NULL) && (strSrc != NULL));
    char *address = strDest;
    while ( n-- && (*strDest++ = *strSrc++) != '\0');
    return address;
}
```

### strcpy_s

```c++
// 是 strcpy 的一种更安全的变体，用于避免缓冲区溢出和其他潜在的安全漏洞。可以确保目标缓冲区有足够的空间来容纳源字符串，并且在出现错误时提供错误处理机制
// 成功返回 0 失败返回非零值，并将目标缓冲区设置为空字符串
errno_t strcpy_s(char *dest, rsize_t destsz, const char *src); // _1:目标的内存地址 _2：目标缓冲区的大小 _3:源内存地址 return: errno_t 
```

- **注意点：** **C++ 11**

1. **缓冲区溢出保护**: `strcpy_s` 通过检查目标缓冲区的大小来防止缓冲区溢出
2. **错误处理**: 提供了明确的错误返回值和错误处理机制。
3. **安全性**: 提高了字符串操作的安全性，特别是在处理用户输入或其他不受信任的数据时
4. src 和 dest 所指的内存区域**不能重叠**

### strncpy_s

```c++
// strncpy 的变体，同样是用于避免缓冲区溢出,可以防止缓冲区溢出并确保目标缓冲区始终以空字符 '\0' 结尾。
// _1:目标的内存地址 _2：目标缓冲区的大小 _3:源内存地址 _4:拷贝的长度
// // 成功返回 0 失败返回非零值，并将目标缓冲区设置为空字符串
errno_t strncpy_s(char *dest, rsize_t destsz, const char *src, rsize_t count);
```

- 注意点： **C++ 11**

1. **确保目标字符串以 `'/0'` 结尾**：如果 src 长度小于 count 则填充，若大于 则截断，然后在目标字符串后面加 `'/0'` , `strncpy` 则不会
2. **缓冲区溢出保护**: `strcpy_s` 通过检查目标缓冲区的大小来防止缓冲区溢出
3. src 和 dest 所指的内存区域**不能重叠**

### memcpy

```C++
// 从src的开始位置拷贝n个字节的数据到dest。如果dest存在数据，将会被覆盖
void *memcpy(void *dest, const void *src, size_t n); // _1:目标内存地址 _2:源地址 _3：要拷贝的字节数 return:指向目标内存地址的指针
```

```c++
void * mymemcpy(void *dest, const void *src, size_t n)
{
    if (dest == NULL || src == NULL) // // 函数入口要检查源地址和目标地址是否有空地址，否则会产生不可预料的错误
          return NULL;
    char *pDest = static_cast <char*>(dest); // 按照一个字节一个字节来操作，故将 void* 转为 char* 如果4个字节来操作，就 int*
    const char *pSrc  = static_cast <const char*>(src);
    if (pDest > pSrc && pDest < pSrc+n) // 判断是否存在内存重叠，这里就是源内存后面与目标内存前面有重叠，故需要从后往前拷贝
    {
        for (size_t i=n-1; i != -1; --i) // 从后往前，防止重叠区域被覆盖(踩内存) 自己画个草稿就好理解了
        {
                pDest[i] = pSrc[i];
        }
    }
    else // 
    {
        for (size_t i= 0; i < n; i++) // 没有重叠，或者目标内存包含与源内存，那就可以从前向后拷贝
        {
                pDest[i] = pSrc[i];
        }
    }

    return dest; // 返回目标内存的指针
}
```

- 注意点：

1. **不关心据类型或内容**，无脑拷贝，遇到`'\0'`不会终止
2. **缓冲区溢出**：确保目标内存区域足够大(至少 n 个)，否则会导致未定义行为
3. **内存重叠**：源内存与目标内存区域不应该有重叠，不确定的时候就用 `memmove`

### memmove

```c++
// 特别适用于源和目标内存区域可能重叠的情况, 能正确处理重叠区域，确保数据不会被破坏 
void *memmove(void *dest, const void *src, size_t n); // _1:目标内存地址 _2:源内存地址 _3:要复制的字节数 return:指向目标内存地址的指针
```

- 注意点：

1. **不关心据类型或内容**，无脑拷贝，遇到`'\0'`不会终止
2. **缓冲区溢出**：确保目标内存区域足够大**(至少 n 个)，否则会导致未定义行为



**==综上==**：

| 方法      | 目标缓冲区溢出 | 内存重叠 |
| --------- | -------------- | -------- |
| strcpy    | ❌              | ❌        |
| strncpy   | ❌              | ❌        |
| strcpy_s  | ✔              | ❌        |
| strncpy_s | ✔              | ❌        |
| memcpy    | ❌              | ❌        |
| memmove   | ❌              | ✔        |

**防止目标缓冲区溢出是开发者的责任，需要确保目标缓冲区足够大以容纳要复制的数据**

## 类型转换 

以下均为 C++ 11 引入

### static_cast<void*>() 静态转换

 更安全的转换方式，它在**编译时**检查转换的合法性。它通常用于基类和派生类指针之间的转换，或者具有相关类型转换操作符的类

**应用场景**：

1. 在相关类型之间进行转换，比如整数类型和浮点类型之间，或者将 `void*` 转换为具体类型的指针
2. 在类层次结构中**向上转型**（从子类指针或引用转换为父类指针或引用），这种转换在类层次结构中是**安全**的
3. 向下转型（从父类指针或引用转换为子类指针或引用），但这要求转换是合法的，即实际的对象类型确实是目标子类类型。如果不是，结果是未定义的(这时可以用 **dynamic_cast**)

```c++
int a = 10; double b = static_cast<double>(a); // 将整数a转换成浮点数b 
Base* ptrB = static_cast<Base*>(new Derived()); // 将派生类对象指针转换为基类指针
```

### dynamic_cast 动态转换

主要用于处理多态类型的**安全向下转换**（也就是父类向子类转换）。 如果转换**不合法(即此时基类指针或引用指向的对象类型并非目标子类类型)**，对于指针类型，`dynamic_cast` 会返回空指针 `nullptr`； 对于引用类型，它会抛出 `std::bda_cast` 异常

```c++
// 创建一个 Derived1 对象，但是以 Base 类型指针存储
Base* base = new Derived1;

// 现在，我们想要将 base 指针转换为 Derived1 类型的指针(这是可以的，因为此时 base 指针实际指向的就是 Derived1 类的对象)
Derived1* derived1 = dynamic_cast<Derived1*>(base);

if (derived1 != nullptr) { 
    // 转换成功，调用 Derived1 类的函数
    derived1->derived1SpecificFunction();
} else {
    // 转换失败，可能是 base 实际上指向基类实例或者其他派生类的实例
    std::cout << "Conversion to Derived1* failed.\n";
}

// 尝试转换到 Derived2 类型，应该失败(因为此时 base 指针实际指向的是 Derived1 类的对)
Derived2* derived2 = dynamic_cast<Derived2*>(base);

if (derived2 != nullptr) {
    // 这段代码不应该被执行，除非 base 真的指向 Derived2 的实例
    std::cout << "Conversion to Derived2* worked (unexpected).\n";
} else {
    std::cout << "Conversion to Derived2* failed (expected).\n";
}

```

### reinterpret_cast<void *>()重新解释转换

`reinterpret_cast` 是 C++ 中的一个类型转换运算符，它用于执行低级别的、不安全的类型转换。与其他类型转换运算符（如 `static_cast`、`dynamic_cast` 和 `const_cast`）相比，`reinterpret_cast` 提供了最少的类型检查。它基本上可以将任何指针类型转换为任何其他指针类型，甚至可以将指针转换为足够大的整数类型，反之亦然

**应用场景**：

1. 当需要将一种指针类型转换为**完全不同**的指针类型时。
2. 当需要将指针和足够大的整数类型之间进行转换时。
3. 当需要操作指针的二进制表示时，例如清除指针的某些位

```c++
// 指针与整数之间的转换
void* ptr= reinterpret_cast<void*>(0xdeadbeef); // 将整数转换为void*指针
std::uintptr_t addr= reinterpret_cast<std::uintptr_t>(ptr);  // 将void*指针转换为整数
std::cout<<"ptr:"<<ptr<<std::endl;   // 0xdeadbeef  
std::cout<<"node:"<<addr<<std::endl; // 3735928559

// 不同类型指针之间的转换
int* iptr = new int(42);
// 转换 int* 到 char*，可能为了操作内存块的单个字节
char* cptr = reinterpret_cast<char*>(iptr);

// 修改 int 值的第一个字节
*cptr = 'A';

// 函数指针之间的转换
typedef void (*FuncPtr)();
void someFunction() {}

FuncPtr funcPtr = reinterpret_cast<FuncPtr>(&someFunction);
```

### const_cast 常量转换

**const_cast 是C++中用来移除变量的 const 性质的类型转换操作符。它的典型用途包括：**

1. 在有const 和非const版本的重载函数中进行转换。

2. 当你需要向一个只接受非 const指针或者引用的函数传递 const数据时。【可以用这个转换下】

3. 当需要修改由const定义 但实际上不应该是 const 的遗留代码的数据时

```c++
void print(char *str) {
    std::cout << str << std::endl;
}

int main() {
    const char *cstr = "Hello World";
    // print(cstr); // 错误：不能从const char*转换为char*
    print(const_cast<char *>(cstr)); // 移除 cstr 的 const 性质
```

## 细枝末节

### nullptr 调用成员函数

**nullptr** 可以调用成员函数，因为在编译时对象就绑定了函数地址，和指针空不空没关系

```c++
class animal
{
public:
	void sleep() {std::cout << "animal sleep" << std::endl;}
	void breathe() {std::cout << "animal breathe haha" << std::endl;}
};
class fish: public animal
{
public:
	void breathe() {std::cout << "fish bubble" << std::endl;}
};

int main()
{
	animal *pAn = nullptr; // animal An; An.breathe(); 也一样会打印
	pAn->breathe();   // 打印：animal breathe haha
	fish *pFish = nullptr; // fish Fish; Fish.breathe(); 也一样会打印
	pFish->breathe(); // 打印：fish bubble

	return 0;
}
```

**编译时对象就绑定了函数地址**，和指针空不空没关系。`pAn->breathe();`编译的时候，函数的地址就和指针`pAn`绑定了；调用`breath(*this)`, `this`就等于`pAn`。由于函数中没有需要解引用`this`的地方，所以函数运行不会出错，但是若用到`this`，因为`this=nullptr`，运行出错。

`nullptr` 的类型是 `std::nullptr_t`，它可以隐式转换为任意指针类型，但是不能转换为整型类型。这避免了用 `0` 或 `NULL` 表示空指针时可能带来的类型歧义

### 内联函数与宏函数

| 区别     | 内联函数                                                     | 宏函数                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 定义     | 编译器在编译时将内联函数的代码直接插入到每个调用点，而不是进行一次普通的函数调用，省去了压栈、弹栈的开销 | 宏定义不是函数，但是使用起来像函数，预处理器用复制宏代码的方式代替函数的调用，省去了压栈、弹栈的开销 |
| 时机     | 在编译的时候进行代码插入，编译器会在每处调用内联函数的地方直接把内联函数的内容展开， | 预编译的时候把所有的宏名用宏体来替换，简单的说就是字符串替换 |
| 类型检查 | 在编译的时候会进行类型的检查                                 | 没有类型检查的，无论对还是错都是直接替换                     |

**内联函数的限制**：

- 只有那些函数体积较小的函数才适合内联。较大的函数体积可能导致代码膨胀，反而降低性能。内联是以代码膨胀（复制）为代价，仅仅省去了函数调用的开销，从而提高函数的执行效率。如果执行函数体内代码的时间，相比于函数调用的开销较大，那么效率的收获会很少
- 递归函数通常不能内联，因为递归调用自身会导致无限展开
- 内联需要在**编译时**能够确定实际调用的函数，因此虚函数通常不会内联
- `inline`关键字只是建议，实际的内联决策由**编译器**根据具体情况来做

### 大端存储与小端存储

- **大端存储** ：高位字节存储在内存的低地址处，低位字节存储在高地址处
  假设有一个32位整数 `0x12345678`，在大端存储中的内存表示如下：

```diff
地址  |  内容
------+--------
0x00  |  0x12
0x01  |  0x34
0x02  |  0x56
0x03  |  0x78
```

- **小端存储** ：低位字节存储在内存的低地址处，高位字节存储在高地址处

```diff
地址  |  内容
------+--------
0x00  |  0x78
0x01  |  0x56
0x02  |  0x34
0x03  |  0x12
```

- **应用场景**：

1. 大端存储常用于网络传输协议，例如TCP/IP。网络字节序（Network Byte Order）通常是大端格式，这样做的目的是简化协议设计和提高可读性
2. 小端存储常用于大多数现代计算机体系结构，包括x86和x86-64。它的优点是对于逐字节处理和数据结构解析更加直观和高效

- **主机字节序与网络字节序的转换**：

```C
int main() {
    uint16_t host_port = 0x1234;
    uint32_t host_address = 0x12345678;

    // 主机字节序转换为网络字节序
    uint16_t net_port = htons(host_port);       // 主机字节序转换为网络字节序（16位短整数）用于端口
    uint32_t net_address = htonl(host_address); // 主机字节序转换为网络字节序（32位长整数）用于ip

    // 网络字节序转换为主机字节序
    uint16_t host_port_converted = ntohs(net_port);			// 网络字节序转换为主机字节序（16位短整数） 用于端口
    uint32_t host_address_converted = ntohl(net_address);   // 网络字节序转换为主机字节序（32位长整数） 用于ip

    return 0;
}
```

- **用联合体判断**：联合体变量总是从低地址开始存储

```C++
union test{
    unsigned char c;
    unsigned int  i;
} ;

void* myjudge(test a)
{
	if (a.c == 0x78) { 		   
		printf("Little-Endian\n"); // 低地址存低位字节---小端
	} else if (a.c == 0x12) {  
		printf("Big-Endian\n");	   // 低地址存高位字节---大端
	} else {
		printf("Unknown Endian\n");
	}
	return nullptr;
}
int main()
{
	test a;
	a.i = 0x12345678; 
	myjudge(a); // Little-Endian

	a.i = htonl(a.i);
	myjudge(a); // Big-Endian

	a.i = ntohl(a.i);
	myjudge(a); // Little-Endian
	
	return 0;
}
```

# 服务器项目复盘

1. main()中开启两个进程：**网络服务器进程 + 日志服务器进程 **         
2. 网络服务器中开启**子进程**客户端处理进程，将**`accept`**的连接套接字全部发送给客户端处理进程处理后续的I/O （Reactor）
3. 其他进程与日志服务器进程通信采用**本地套接字**方式
4. Linux下的后台开发，先把**进程关系**理清楚(进程关系图)，单进程多线程当然可以完成功能实现，但是进程是操作系统资源分配的==最小单位==（即若进程被挂起，则进程下的所有线程都不再具有系统资源的操作权限），故要充分利用系统资源，最好的形式是**多进程多线程**。即将一个整体功能分散到多个进程中，实现==资源利用率最大化==，否则多线程在一个进程内竞争，资源利用率低！ （线程是操作系统调度的基本单位，调度程序以线程为基本单位进行时间片分配和切换，进程本身并不是直接被调度执行的实体）

![image-20240605214002482](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745026.png)                                                              



## 模板类---泛型编程 + C++11新特性 + 多态

**==通用的==可调用对象类，用于生成==任意==函数指针与参数数量的==可调用对象== **

1.  定义可调用对象基类（为了隔绝模板的传染性，在其他类中的可调用对象均声明为基类指针类型）

   ```c++
   class CFunctionBase 
   {
   public:
       virtual ~CFunctionBase() {}
       virtual int operator()() { return -1; }              // 表示没有延迟参数，即实例化一个可调用对象后其所有参数已经确定
       virtual int operator()(CSocketBase*) { return -1; }  // 表示有一个延迟参数，即调用一个可调用对象时会传参
       virtual int operator()(CSocketBase*, const Buffer&) { return -1; } // 表示有两个延迟参数
       // ... 可重载n个参数不同的函数调用运算符
   };
   ```

2. 定义可调用对象模版类，继承自基类，支持传任意函数指针与参数(C++11 **`std::bind std::forward std::function`** )

   ```C++
   template <typename _FUNCTION_, typename... _ARGS_> // 无延迟参数可调用对象模版类
   class CFunction : public CFunctionBase 
   {
   public:
       CFunction(_FUNCTION_ func, _ARGS_... args) // 基于传入的参数(函数指针、函数参数)实例化模版
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CFunction() {}
       virtual int operator()() { 
           return m_binder(); 
       }
       std::function<int()> m_binder; // 可调用对象
   };
   
   template<typename _FUNCTION_, typename... _ARGS_> // 单个延迟参数可调用对象模版类
   class CConnectedFunction :public CFunctionBase
   {
   public:
       CConnectedFunction(_FUNCTION_ func, _ARGS_... args)
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CConnectedFunction() {}
       virtual int operator()(CSocketBase* pClient) {
           return m_binder(pClient); // 实例化模板时传入占位符来实现支持延迟参数
       }
       std::function<int(CSocketBase*)> m_binder;
   };
   
   template<typename _FUNCTION_, typename... _ARGS_> // 两个延迟参数可调用对象模版类
   class CReceivedFunction :public CFunctionBase
   {
   public:
       CReceivedFunction(_FUNCTION_ func, _ARGS_... args)
           :m_binder(std::bind(std::forward<_FUNCTION_>(func), std::forward<_ARGS_>(args)...))
       {}
       virtual ~CReceivedFunction() {}
       virtual int operator()(CSocketBase* pClient, const Buffer& data) {
           return m_binder(pClient, data);
       }
       std::function<int(CSocketBase*, const Buffer&)> m_binder;
   };
   ```

3. 在要使用可调用对象的类中定义**可调用对象成员变量**与**初始化可调用对象的成员函数 **(**eg: 进程类、线程类、客户端处理接口类**)

   ```C++
   class CUseFunc // 要使用可调用对象的类
   {
   public:
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc(_FUNCTION_ func, _ARGS_... args) { // 初始化可调用对象的成员函数
           m_func = new CFunction<_FUNCTION_, _ARGS_...>(func, args); // 无延迟参数 多态(基类指针指向派生类对象)
           m_func = std::make_shared<CFunction<_FUNCTION_, _ARGS_...>>(func, args);
           m_func = std::make_shared<CFunction<_FUNCTION_, _ARGS_...>>(func, args...); // 智能指针封装
           return 0;
       }
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc1(_FUNCTION_ func, _ARGS_... args) {
           m_func1 = new CConnectedFunction<_FUNCTION_, _ARGS_...>(func, args...); // 一个延迟参数
           return 0;
       }
       template<typename _FUNCTION_, typename... _ARGS_>
       int SetFunc2(_FUNCTION_ func, _ARGS_... args) {
           m_func1 = new CReceivedFunction<_FUNCTION_, _ARGS_...>(func, args...); // 两个延迟参数
           return 0;
       }
       int func3(CSocketBase* sock, const Buffer&){} // 非静态成员函数
   private:
       CFunctionBase* m_func; // 可调用对象指针的成员变量
       std::shared_ptr<CFunction> m_func; // 智能指针封装
       CFunctionBase* m_func1;  
       CFunctionBase* m_func2;
       CFUnctionBase* m_func3;
   };
   ```

4.  初始化可调用对象（模版函数、**`std::placeholders`**）==注意==如果函数调用方式是**`_thiscall`**(类的非静态成员函数)，第一个参数要传**`this`**

   ```C++
   int func() // 函数指针 注意函数签名中有多少参数都没关系，关键是有没有延迟参数，即可调用对象生成后，在调用时还需要传入参数
   {
       printf("this is func, without delay param!\n");
   }
   int func1(CSocketBase* sock) // 函数指针
   {
       printf("this is func1, with a delay param CSocketBase*!\n");
   }
   int func2(CSocketBase* sock, const Buffer& data) // 函数指针
   {
       printf("this is func2, with two delay param!\n");
   }
   
   int main()
   {
       CUseFunc useFunc;
       useFunc.SetFunc(func); // 初始化可调用对象
       useFunc.SetFunc1(func1, std::placeholders::_1); // 初始化有一个延迟参数的可调用对象 一个占位符
       useFunc.SetFunc2(func2, std::placeholders::_1, std::placeholders::_2); // 初始化有两个延迟参数的可调用对象 两个占位符
       useFunc.SetFunc2(func3, this, std::placeholders::_1, std::placeholders::_2); // 封装类的非静态成员函数，需要传this
       
   }
   ```

5.  调用

   ```C++
   (*m_func)(); // 调用
   CSocketBase* para1;
   const Buffer para2;
   (*m_func1)(para1); // 调用
   (*m_func2)(para1, para2); // 调用
   (*m_func3)(para1, para2); // 调用
   ```

## 进程类的设计(CProcess)---进程间通信

- 创建子进程(`CreateSubProcess()`)，在子进程中执行线程入口函数

- 进程入口函数采用上述**泛型编程**思想以支持**任意**函数指针与参数，在此不赘述

- 由于网络服务器进程需要将其**`accept`**到的连接套接字发送给其子进程(客户端处理进程)，我们使用`socketpair()`

  ![image-20240605221512678](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745027.png) 

  ```C++
  int pipes[2]; // 存储socketpair()创建的两个fd 本项目中，pipes[0]用于子进程读，pipes[1]用于父进程写(如果要父子进程互传，则需要两个pipes[2])
  socketpair(AF_LOCAL, SOCK_STREAM, 0, pipes); // 创建一对套接字放在pipes中 注意必须在fork()前创建，这样父子进程就都拥有这对套接字
  
  //网络服务器进程(主)将connect()上来的网络用户连接套接字及其地址传给客户端处理进程(子)
  int SendSocket(int fd, const sockaddr_in* addrin) {
          struct msghdr msg; // 用于在套接字间传递消息的元数据结构。它允许发送和接收消息时，同时携带多个缓冲区的数据、目标地址、控制信息等
          iovec iov; // 用于描述一块连续内存区域的信息,指定数据的缓冲区和长度
          char buf[20] = ""; // 初始化一个大小为 20 字节的缓冲区 buf，用于存放地址信息
          bzero(&msg, sizeof(msg));
          memcpy(buf, addrin, sizeof(sockaddr_in));
          iov.iov_base = buf; // 设置iov结构体成员
          iov.iov_len = sizeof(buf);
          msg.msg_iov = &iov; // 将iov结构体设置到msghdr结构体中
          msg.msg_iovlen = 1;
  
          cmsghdr* cmsg = (cmsghdr*)calloc(1, CMSG_LEN(sizeof(int))); // 用于在套接字间传递控制信息的结构体，可以传递fd等控制信息
          if (cmsg == NULL)return -1;
          cmsg->cmsg_len = CMSG_LEN(sizeof(int));
          cmsg->cmsg_level = SOL_SOCKET; // 控制信息的级别
          cmsg->cmsg_type = SCM_RIGHTS; // 控制信息的类型，这里表示传递fd
          *(int*)CMSG_DATA(cmsg) = fd; // 控制信息的数据部分
          msg.msg_control = cmsg; // 将cmsghdr设置到msghdr结构体中
          msg.msg_controllen = cmsg->cmsg_len;
  		// sendmsg()系统调用，用于发送消息到指定的套接字 可以在一个系统调用中发送多个缓冲区的数据
          ssize_t ret = sendmsg(pipes[1], &msg, 0); // 将fd和地址信息一起发给子进程，pipes[1]用于主进程写，子进程中需关闭这端(pipes[1]=0)
          free(cmsg);
          return 0;
      }
  // 客户端处理进程(子)接收网络服务器进程(主)发过来的网络用户连接套接字及其地址
  int RecvSocket(int& fd, sockaddr_in* addrin) 
      {
          msghdr msg; // 消息结构体
          iovec iov;
          char buf[20] = "";
          bzero(&msg, sizeof(msg));
          iov.iov_base = buf;
          iov.iov_len = sizeof(buf);
          msg.msg_iov = &iov;
          msg.msg_iovlen = 1;
  
          cmsghdr* cmsg = (cmsghdr*)calloc(1, CMSG_LEN(sizeof(int)));
          if (cmsg == NULL)return -1;
          cmsg->cmsg_len = CMSG_LEN(sizeof(int));
          cmsg->cmsg_level = SOL_SOCKET;
          cmsg->cmsg_type = SCM_RIGHTS;
          msg.msg_control = cmsg;
          msg.msg_controllen = CMSG_LEN(sizeof(int));
      	// recvmsg()系统调用，用于从指定的套接字接收消息。它可以在一个系统调用中接收多个缓冲区的数据
          ssize_t ret = recvmsg(pipes[0], &msg, 0); // 接收fd和地址信息，pipes[0]用于子进程读，主进程中需关闭这端(pipes[0]=0)
          memcpy(addrin, buf, sizeof(sockaddr_in)); // 将接收到地址信息拷贝给出参2，即这样子进程就拿到了地址信息
          fd = *(int*)CMSG_DATA(cmsg); // 将接收到的fd拷贝给出参1，这样子进程就拿到了连接套接字
          free(cmsg);
          return 0;
      }
  ```

- [进程间通信的方式](https://xiaolincoding.com/os/4_process/process_commu.html#%E6%80%BB%E7%BB%93)：管道、消息队列、共享内存、信号量、信号、Socket

- [守护进程](https://www.bilibili.com/video/BV1EG4y1d7rp/?spm_id_from=333.337.search-card.all.click&vd_source=62aa2836d3b2cff426a89393eeb8efd4)：是在后台运行的一种特殊类型的进程，通常在操作系统启动时启动，并且在操作系统关闭时关闭。它们通常在没有用户交互的情况下在后台运行，并且通常不受终端控制。

  ```C++
  static int SwitchDeamon() {   // 将进程转为守护状态
          pid_t ret = fork();   // 1. 创建子进程并退出父进程
          if (ret > 0) exit(0); 
          // 子进程内容如下
          ret = setsid(); // 2.创建新会话，让子进程成为会话首进程和新的进程组组长，实现与之前的终端、会话和控制端脱离
          ret = fork(); // 3.创建孙进程并结束子进程
          if (ret > 0) exit(0);
          // 孙进程内容如下，进入守护状态
          for (int i = 0; i < 3; i++) close(i); // 4.关闭标准输入输出和错误
          umask(0); // 5.清除文件创建屏蔽字
          signal(SIGCHLD, SIG_IGN); // 6.忽略子进程的退出信号 表示守护进程对其子进程结束不关心，由内核回收
          return 0;
      }
  ```

## epoll的封装(CEpoll)

- [epoll](https://zhuanlan.zhihu.com/p/367591714) :用到的==**结构体**==

  - **`epoll_event`**

  ![image-20240606175331414](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745028.png) 

  其中，**`events`**可以是以下几个宏的集合(bitmap，**按位|**可以增加集合属性，**按位&**可以判断集合属性)：

  1. EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；
  2. EPOLLOUT：表示对应的文件描述符可以写；
  3. EPOLLPRI：表示对应的文件描述符有紧急的数据可读（这里应该表示有带外数据到来）；
  4. EPOLLERR：表示对应的文件描述符发生错误；
  5. EPOLLHUP：表示对应的文件描述符被挂断；
  6. EPOLLET ：将 EPOLL 设为边缘触发(Edge Trigger)模式，这是相对于水平触发(Level Trigger)来说的。
  7. EPOLLONESHOT：只监听一次事件，当监听完这次事件之后，如果还需要继续监听这个 socket 的话，需要再次把这个 socket 加入到 EPOLL 队列里

  - **`event_poll`**

    ```C++
    //struct eventpoll 的定义
    // file：fs/eventpoll.c
    struct eventpoll {
    
        //sys_epoll_wait用到的等待队列
        wait_queue_head_t wq;
    
        //接收就绪的描述符都会放到这里
        struct list_head rdllist;
    
        //每个epoll对象中都有一颗红黑树
        struct rb_root rbr;
    
        ......
    }
    ```

  1. **wq**:  等待队列链表。软中断数据就绪的时候会通过 wq 来找到阻塞在 epoll 对象上的用户进程。
  2. **rbr：** 红黑树。为了支持对海量连接的高效查找、插入和删除，eventpoll 内部使用的就是红黑树。通过红黑树来管理用户主进程accept添加进来的所有 socket 连接。
  3. **rdllist：** 就绪的描述符链表。当有连接就绪的时候，内核会把就绪的连接放到 rdllist 链表里。这样应用进程只需要判断链表就能找出就绪进程，而不用去遍历红黑树的所有节点了。

- epoll的三个==**接口函数**==

  - **`epoll_create`**

    ```C++
    int epoll_create(int size);
    ```

    1. **功能：**该函数生成一个 epoll 专用的文件描述符
    2. **参数size:** 用来告诉内核这个监听的数目一共有多大，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。自从 linux 2.6.8 之后，size 参数是被忽略的，也就是说可以填只有大于 0 的任意值
    3. **返回值：**如果成功，返回epoll 专用的文件描述符，否者失败，返回-1

    ```C++
    int epoll_create1(int flags);
    ```

    1. **功能：**该函数生成一个 epoll 专用的文件描述符。
    2. **参数flags:** 允许传递额外的选项来控制 epoll 实例的行为,目前支持的选项有**EPOLL_CLOEXEC**。告诉操作系统在创建 epoll 实例时将其设置为 close-on-exec（CLOEXEC）模式。在 CLOEXEC 模式下，当一个进程调用 fork() 创建子进程或调用 exec() 执行一个新程序时，内核会**自动关闭** epoll 实例，以防止在子进程或新程序中泄漏 epoll 文件描述符**。这是一种**安全措施**，确保 epoll 文件描述符不会在不应该的地方被误用
    3. **返回值：**如果成功，返回epoll 专用的文件描述符，否者失败，返回-1

  - **`epoll_ctl`**

    ```c++
    int epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); 
    ```

    1. **功能：**epoll 的事件注册函数，它不同于 select() 是在监听事件时告诉内核要监听什么类型的事件，而是在这里先注册要监听的事件类型

    2. **参数op:** 表示动作，用三个宏来表示：

       EPOLL_CTL_ADD：注册新的 fd 到 epfd 中

       EPOLL_CTL_MOD：修改已经注册的fd的监听事件

       EPOLL_CTL_DEL：从 epfd 中删除一个 fd

    3. **参数fd:** 需要监听的文件描述符

    4. **参数event:** 告诉内核要监听什么**事件及用户自定义的传参**，epoll_event 结构体指针，参考上文

    5. **返回值：**0表示成功，-1表示失败

  -  **`epoll_wait`**

    ```C++
    int epoll_wait(int epfd, struct epoll_event * events, int maxevents, int timeout); 
    ```

    1. **功能：**等待事件的产生，收集在 epoll 监控的事件中已经发生的事件，类似于 select() 调用
    2. **参数epfd:** epoll 专用的文件描述符，epoll_create()的返回值
    3. **参数events:** 分配好的 epoll_event 结构体数组，epoll 将会把发生的事件赋值到events 数组中（events 不可以是空指针，内核只负责把数据复制到这个 events 数组中，不会去帮助我们在用户态中分配内存）
    4. **参数maxevents:** maxevents 告之内核这个 events 有多少个
    5. **参数timeout:** 超时时间，单位为毫秒，为 -1 时，函数为阻塞
    6. **返回值：** 成功--->表示返回需要处理事件的数目 、超时--->返回0、  失败--->返回-1

- **EpollData**：将联合体 **epoll_data_t** 封装成类，方便赋值

- **CEpoll**: 封装的 epoll 类，支持创建、等待事件、注册事件、修改事件、删除已注册的事件以及关闭**epoll**等操作

  ```C++
  int m_epoll; // 类中唯一成员变量 epoll 专用的文件描述符
  using EPEvents = std::vector<epoll_event>; // 创建epoll_event动态数组的别名 
  ```

  ```C++
  // 禁止进行复制构造和赋值运算，因为epoll本质是内核对象，用户态无法复制构造或赋值 构造完CEpoll实例后，只能通过Create()接口创建
  CEpoll(const CEpoll&) = delete; // 不会实现 没必要写参数名
  CEpoll& operator=(const CEpoll&) = delete; // 不会实现，没必要写参数名
  
  // 创建epoll专用fd(树根)
  int Create(unsigned count); // 基于 epoll_creat1
  
  // 等待事件的发生 <0->发生错误 =0->没有事情发生 >0->成功拿到事件 para1:出参，用来接收epoll返回的发生的事件 para2:超时时间
  ssize_t waitEvents(EPEvents& events, int timeout = 10); // 基于 epoll_wait
  
  // 注册fd para1:加入epoll监控的fd para2：自定义数据，一般用来传递额外参数 para3:需要监听的事件类型，默认为可读
  int Add(int fd, const EpollData& data = EpollData((void*)0), uint32_t events = EPOLLIN);  // 这三个均基于 epoll_ctl
  // 修改已经注册的fd的监听事件
  int Modify(int fd, uint32_t events, const EpollData& data = EpollData((void*)0));
  // 删除已经注册的fd
  int Del(int fd)；
      
  void Close(); // 关闭epoll 
  ```

## 套接字的封装(CSocket)---支持本地、网络、UDP、TCP、客户端、服务器所使用的套接字

- 套接字属性：**位掩码** + 枚举类型 

  ```C++
  enum SockAttr { // 套接字属性
  	SOCK_ISSERVER = 1,  // 是否为服务器，0-客户端 1-服务器				  00001
  	SOCK_ISNOBLOCK = 2, // 是否阻塞	    0-阻塞   1-非阻塞				00010
  	SOCK_ISUDP = 4,     // 是否为UDP，   0-tcp   1-udp				   00100
  	SOCK_ISIP = 8,      // 是否为IP协议  0-本地套接字 1-IP协议(网络套接字)  01000   
  	SOCK_ISREUSE = 16   // 是否重用地址  0-不重用 1-重用                  10000 
      // 即使端口处于 TIME_WAIT 状态，也可以立即在该端口上重新绑定一个新套接字 
      // 对于需要频繁启动和停止服务器程序的开发过程特别有用，因为可以避免 "Address already in use" 错误
  }; // 如果这时候套接字属性为attr=11111(二进制)， 通过判断按位与(&)就知道是哪些属性的组合
  ```

- 套接字参数类:**CSockParam**

  ```C++
  // 成员变量
  sockaddr_in addr_in; // 网络套接字地址结构体
  sockaddr_un addr_un; // 本地套接字地址结构体
  Buffer ip; // ip
  short port; // 端口
  int attr; // 参考SockAttr 套接字属性
  ```

- 套接字抽象类：**CSocketBase**

  封装套接字抽象接口类，抽象出 Init()、Link()、Recv()、Send()、Close()五个接口，将**C/S通信流程抽象**，屏蔽了网络套接字与本地套接字的区别

  ![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745029.png) 

  ```C++
  // 成员变量
  protected: // 只让子类继承 不让外部访问 故为protected
  	int m_socket; // 套接字fd，默认-1（在服务器端是监听套接字）
  	int m_status; // 套接字当前状态，0-初始化未完成 1-初始化完成 2-连接完成 3-已关闭
  	CSockParam m_param; // 初始化套接字参数
  // 成员方法
  // 1.Init():服务器-套接字创建、bind、listen 客户端-套接字创建
  virtual int Init(const CSockParam& param) = 0; // 根据输入参数来创建本地、网络、客户端
  // 2.Link():服务器-accept 客户端-connect 对于udp，这里可以忽略
  // 这里的参数，对于服务器来说，connect()会返回一个连接套接字，在Link中会配置这个套接字，需要用二级指针传出去，抽象类没有实例，不能引用传参
  virtual int Link(CSocketBase** pClient = NULL) = 0; // 对于客户端不需要这个参数，故默认为 NULL
  // 3.Send()
  virtual int Send(const Buffer& data) = 0;
  // 4.Recv()
  virtual int Recv(Buffer& data) = 0;
  // 5.Close()
  virtual int Close();
  ```

- 通用套接字类：**CSocket :public CSocketBase**

  ```C++
  // 成员方法
  virtual int Init(const CSockParam& param){
      // 1.创建socket
      int type = (m_param.attr & SOCK_ISUDP) ? SOCK_DGRAM : SOCK_STREAM; // 若参数属性为UDP，则设置对应的类型
      if (param.attr & SOCK_ISIP) // 如果是IP协议
          m_socket = socket(PF_INET, type, 0);  // 创建网络套接字
      else
          m_socket = socket(PF_LOCAL, type, 0); // 创建本地套接字
      // 2.判断是否为服务器，服务器的话还要 bind listen
      if (param.attr & SOCK_ISIP) // 如果是网络套接字，那就绑定网络套接字的地址结构体
     		bind(m_socket, m_param.addrin(), sizeof(sockaddr_in)); // para1:要绑定的套接字fd para2:要绑定的地址和端口信息(一个地址结构体*)
      else
          bind(m_socket, m_param.addrun(), sizeof(sockaddr_un)); // para1:要绑定的套接字fd para2:要绑定的地址和端口信息(一个地址结构体*)
      listen(m_socket, 32);
      
  virtual int Link(CSocketBase** pClient = NULL){ // 外面如果是服务器调这个，给一个空的CSocketBase**过来，accept得到的连接套接字就能传出去
      // 1.如果是服务器，accept
      CSockParam param; // 默认 客户端、阻塞、tcp、 本地 用来给accept得到的连接套接字初始化
      if (m_param.attr & SOCK_ISIP) { // 网络套接字
          param.attr |= SOCK_ISIP;
          len = sizeof(sockaddr_in);
          fd = accept(m_socket, param.addrin(), &len); // 返回通信套接字 同时将请求连接的客户端的地址信息填到param中
      }
      else { // 本地套接字
          len = sizeof(sockaddr_un);
          fd = accept(m_socket, param.addrun(), &len); // 返回通信套接字 同时将请求连接的客户端的地址信息填到param中
      }
      *pClient = new CSocket(fd); // 配置连接套接字
      (*pClient)->Init(param); // 连接套接字初始化 由于是二级指针传参，会作为出参返回 服务器那边就可以得到一个设置好的与客户端通信的连接套接字对象
      // 2.如果是客户端，connect
      if (m_param.attr & SOCK_ISIP) // 网络套接字
          connect(m_socket, m_param.addrin(), sizeof(sockaddr_in)); 
      else // 本地套接字
          connect(m_socket, m_param.addrun(), sizeof(sockaddr_un));
  }
      
  virtual int Send(const Buffer& data) { // 这里的参数是指定要发送的数据 即发送缓冲区
      ssize_t index = 0; // 已发送的数据
      while (index < (ssize_t)data.size()) {
          ssize_t len = write(m_socket, (char*)data + index, data.size() - index); // 返回写入buffer的长度
          index += len;
      }
  }
      
  virtual int Recv(Buffer& data) { // 出参，读入的数据通过参数返回 这里的参数用来读数据 即接收缓冲区
      data.resize(1024 * 1024); // 给缓冲区大小
      ssize_t len = read(m_socket, data, data.size());
      if (len > 0) { // 读了len个字节大小
          data.resize(len); // 通过出参只返回读入的数据
          return (int)len; // 返回收到的数据大小
      }
      data.clear();
      if (len < 0) {
          if (errno == EINTR || errno == EAGAIN) { // read()返回是因为被中断，或非阻塞(即轮循EAGAIN 表示当前没有数据可读，内核buffer没就绪会直接返回)，不能算接收失败
              data.clear();
              return 0; // 没有收到数据 但不算失败
          }
      }
  }
      
  virtual int Close();
  ```

## 线程的封装(CThread)

封装线程类，Start()、Pause()、Stop()、SetThreadFunc() 等接口

```c++
// 成员变量
CFunctionBase* m_function; // 线程函数指针
pthread_t m_thread; // 线程id
bool m_bpaused; // true-暂停 false-运行中
static std::map<pthread_t, CThread*> m_mapThread; // 线程id与线程对象指针的hash_map 属于整个类的所有实例(静态成员)
```

线程函数采用前文**泛型编程**思想以支持**任意**函数指针与参数，在此不赘述

注意还是要通过一个静态线程入口函数+this指针给**`pthread_create`**传参，原因见前文<<线程创建>>

```c++
// 禁止进行复制构造和赋值运算，因为thread本质是内核对象，用户态无法复制构造或赋值
CThread(const CThread&) = delete; //  不会实现 没必要写形参名
CThread operator=(const CThread&) = delete;

int Start() {
    pthread_attr_t attr; // 线程属性对象。线程属性对象包含创建线程时可以指定的各种属性，如堆栈大小、调度策略、继承调度属性等
    pthread_attr_init(&attr); // 初始化线程属性对象
    // 设置线程为 joinable 状态意味着线程在结束时不会自动释放资源，需要调用 pthread_join 来清理资源
    pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_JOINABLE); 
    // 创建线程, para1：出参，存放新线程id para2:线程属性对象 para3:新线程执行的函数(要求全局可见) para4:传递给新线程函数的参数 
    ret = pthread_create(&m_thread, &attr, &CThread::ThreadEntry, this); 
    m_mapThread[m_thread] = this; // hash_map保存线程id和当前线程类对象的映射关系
    ret = pthread_attr_destroy(&attr); // 销毁线程属性对象，释放相关资源
    return 0;
}

int Pause() { // 暂停/恢复
    if (m_bpaused) { // 如果当前处于暂停，修改状态标志为运行
        m_bpaused = false; // 这样子暂停那边的信号处理函数循环就会跳出，不再暂停
        return 0;
    }
    m_bpaused = true; // 当前在运行中，修改状态标志为暂停
    int ret = pthread_kill(m_thread, SIGUSR1); // 发送暂停信号SIGUSR1
    return 0;
}

int Stop() {
    if (m_thread != 0) { // 线程id为0说明不用再停止
        pthread_t thread = m_thread;
        m_thread = 0;
        timespec ts; // 设置等待时间 创建一个 timespec 结构体
        ts.tv_sec = 0; // 秒=0
        ts.tv_nsec = 100 * 1000000; // 100ms 纳秒=10*1000000，即100ms
        // 因为下面要在其他某个线程中尝试等待thread是否结束，故线程创建时属性为：PTHREAD_CREATE_JOINABLE
        int ret = pthread_timedjoin_np(thread, NULL, &ts); // 尝试在 ts 时间内等待线程结束
        if (ret == ETIMEDOUT) { // 在指定的等待时间内，线程没有结束
            pthread_detach(thread); // 将线程分离，以确保当线程最终结束时其资源会被自动释放
            pthread_kill(thread, SIGUSR2); // 向线程发送 SIGUSR2 信号 
        }
    }
    return 0;
}

// 信号处理函数，para1:接收到的信号编号 para2:信号的附加信息 para3:信号处理时的上下文信息
static void Sigaction(int signo, siginfo_t* info, void* context) { 
    if (signo == SIGUSR1) { // 暂停
        pthread_t thread = pthread_self(); // 获取当前的线程id
        auto it = m_mapThread.find(thread); // hash_map中查找线程id及其对应的线程类实例对象
        if (it != m_mapThread.end()) // 找到
            if (it->second) // 线程id对应的线程类对象
                while (it->second->m_bpaused) // 当前线程处于暂停状态就继续暂停，暂停状态再调用Pause()会将m_bpaused置false，就恢复了
                    usleep(1000); // 休眠1ms后继续循环
    else if (signo == SIGUSR2) // 线程退出
        pthread_exit(NULL);
}
```

## 线程池的封装(CThreadPool)

封装线程池类，Start()、Close()、AddTask()、TaskDispatch() 等接口

任务分发机制：**epoll + 本地套接字通信** 避免了线程池中多线程竞争任务带来的互斥同步问题，无需引入需要加锁的任务队列(我是线程池类中定义了epoll成员)

```c++
// 成员变量
Buffer m_path; // 本地套接字地址(即 UNIX套接字文件[.sock]) 线程池类的构造函数中会根据当前时间初始化一个.sock 文件名 bind()时会生成对应的.sock文件
CSocketBase* m_server; // 线程池本地监听套接字
CEpoll m_epoll; // epoll监听I/O事件(其实就是有没有给线程池分配任务)
std::vector<CThread*> m_threads; // 线程池中的线程指针vector
```

```c++
// 成员方法

// 1.创建并初始化本地监听套接字对象 2.创建epoll树根(eventpoll结构 wq-等待队列 rbr-红黑树 rdllist-就绪的fd链表)
// 3 监听套接字挂树 4.创建线程并指定线程函数TaskDispatch() 5.启动线程
int Start(unsigned count) { // 线程池中线程的个数需要在线程池构造时就指定
    m_server = new CSocket(); // 本地监听套接字
    ret = m_server->Init(CSockParam(m_path, SOCK_ISSERVER)); // 监听套接字初始化 socket()->bind()->listen()
    ret = m_epoll.Create(count); // 创建epoll树根
    // *m_server->取到套接字对象->Add()第一个参数会有一个int的隐式类型转换，拿到的就是fd(sock)
    ret = m_epoll.Add(*m_server, EpollData((void*)m_server)); // 监听套接字挂树
    m_threads.resize(count); // 根据参数修改线程vector数量
    for (unsigned i = 0; i < count; i++) {
        m_threads[i] = new CThread(&CThreadPool::TaskDispatch, this); // 创建线程时指定线程函数，传递this指针
        ret = m_threads[i]->Start(); // 启动线程
    }
    return 0;
}

// 1.关闭epoll 2.关闭监听套接字 3.关闭线程池中所有线程 4.删除文件路径(本地套接字通信中服务器ip其实就是.sock文件)
void Close() {
    m_epoll.Close();
    if (m_server) {
        CSocketBase* p = m_server;
        m_server = NULL;
        delete p;
    }
    for (auto thread : m_threads)
    {
        if (thread) delete thread;
    }
    m_threads.clear();
    unlink(m_path);
}

// 支持任意参数的任务函数
template<typename _FUNCTION_, typename... _ARGS_>
// 主进程中调用该函数: 1.建立one thread one client 的连接(与线程池) 2.通过本地套接字将任务发送给线程池
int AddTask(_FUNCTION_ func, _ARGS_... args) {
    static thread_local CSocket client; // 每个线程拥有一个本地套接字对象(线程作为客户端)
    // 静态的但每个线程(static thread_local)调这个函数都会构造一个新的 client 即一个线程对应一个客户端
    ret = client.Init(CSockParam(m_path, 0)); // 初始化客户端套接字 此时服务器的地址已经在m_path中了
    ret = client.Link(); // 客户端的Link() 即 connect() 建立客户端(想要给线程池添加任务的进程/线程)与线程池的连接
    CFunctionBase* base = new CFunction<_FUNCTION_, _ARGS_...>(func, args...); // 任务函数
    Buffer data(sizeof(base));
    memcpy(data, &base, sizeof(base));
    ret = client.Send(data); // 将任务函数对象指针发给线程池的监听套接字
    return 0;
}

// 共享epoll树根 -> 一起wait(都在epoll的等待队列中) -> 谁抢到(竞争到)事件(m_server上的读->连接客户端 pClient上的读->执行任务函数)谁就干(被唤醒)
int TaskDispatch() {
    EPEvents events; // epoll_event 结构体（{event, data}event->希望监听的事件 data->自定义参数）的vector 用来接收epoll_wait()返回
    //esize=发生事件数量，events=出参存储发生的事件(就绪链表)
    ssize_t esize = m_epoll.waitEvents(events); 
    if (esize > 0) {
        for (ssize_t i = 0; i < esize; i++) {
            if (events[i].events & EPOLLIN) { // 读事件
                CSocketBase* pClient = NULL;
                if (events[i].data.ptr == m_server) { // 监听套接字上的读事件，说明是Addtask()里面的Link()
                    ret = m_server->Link(&pClient); // 通过二级指针返回accept()到的连接套接字
                    ret = m_epoll.Add(*pClient, EpollData((void*)pClient)); // 连接套接字挂树(.Add()para3默认为可读事件)
                }
                else { // 连接套接字上的读事件，即有任务请求
                    pClient = (CSocketBase*)events[i].data.ptr;
                    if (pClient) {
                        CFunctionBase* base = NULL;
                        Buffer data(sizeof(base));
                        ret = pClient->Recv(data);
                        memcpy(&base, (char*)data, sizeof(base)); // 得到任务函数
                        if (base != NULL) {
                            (*base)(); // 调用任务函数 base->函数对象指针 *base->可调用对象
                            delete base;
                        }
                    }
                }
            }
    return 0;
}
```

## 日志服务器

**功能**：接收客户端进程、客户端处理进程的**连接请求与写日志**请求(基于**本地套接字**)

```C++
// 成员变量
CThread m_thread; // 日志服务器的线程 只有一个线程负责处理连接和写日志，故不用考虑线程间的互斥同步
CSocketBase* m_server; // 日志服务器的监听套接字
CEpoll m_epoll; // epoll 监听I/O事件
Buffer m_path; // 日志文件存放路径
FILE* m_file; // 日志文件指针 
```

```c++
// 成员方法

// 1.线程函数 主要是执行 epoll_wait 同时对其返回的就绪IO事件进行处理(监听套接字->处理连接、连接套接字->写日志)
int ThreadFunc() { 
    EPEvents events; // epoll_event结构体的动态数组 用来接收epoll_wait()返回的发生事件
    std::map<int, CSocketBase*> mapClients; // 本地通信对象的套接字及对象指针的map
    while (m_thread.isValid() && (m_epoll != -1) && (m_server != NULL)) { // 日志服务器线程OK epoll OK 本地监听套接字对象OK
        ssize_t ret = m_epoll.waitEvents(events, 1000); // 等待事件发生，ret=数量，events=出参存储发生的事件(epoll_event)，超时时间=1ms
        for (; i < ret; i++) {
            if (events[i].events & EPOLLIN) { // 可读
                if (events[i].data.ptr == m_server) { // 监听套接字可读 则处理客户端的连接
                    CSocketBase* pClient = NULL; // 通信套接字对象指针
                    int r = m_server->Link(&pClient); // 通过二级指针返回连接后的通信套接字对象指针
                    // 连接套接字挂树(加入监听并注册事件)
                    r = m_epoll.Add(*pClient, EpollData((void*)pClient), EPOLLIN | EPOLLERR); 
                    mapClients[*pClient] = pClient; // 更新map
                }
                else { // 连接套接字可读 则接收并写日志
                    CSocketBase* pClient = (CSocketBase*)events[i].data.ptr; // 拿到发生可读事件的连接套接字对象指针	
                    Buffer data(1024 * 1024);
                    int r = pClient->Recv(data); // 接收
                    WriteLog(data); // 收到数据 写日志
                }
            }
        }
    } 
    // 释放资源 ... 
    return 0;
}

// 2.构造函数
CLoggerServer() :
	m_thread(&CLoggerServer::ThreadFunc, this) // 初始化线程函数
{
    m_server = NULL;
	char curpath[256] = "";
	getcwd(curpath, sizeof(curpath));
	m_path = curpath;
	m_path += "/log/" + GetTimeStr() + ".log"; // 根据当前系统时间初始化日志文件路径
}

// 3.启动日志服务器
int Start() {// 日志服务器的启动：打开日志文件->创建epoll->创建并初始化本地监听套接字->监听套接字挂树->开启线程
    if (access("log", W_OK | R_OK) != 0) { // 
        mkdir("log", S_IRUSR | S_IWUSR | S_IRGRP | S_IWGRP | S_IROTH);
    } // 检查当前进程对文件 "log" 的读写权限。如果当前进程对 "log" 文件没有读写权限，则创建一个名为 "log" 的目录，并设置相应的权限
    m_file = fopen(m_path, "w+"); // 以读写模式打开日志，如果不存在则创建，如果已经存在则打开文件并清空
    int ret = m_epoll.Create(1); // 创建epoll m_epoll---epoll专用fd
    m_server = new CSocket(); // 创建监听套接字 
    ret = m_server->Init(CSockParam("./log/server.sock", (int)SOCK_ISSERVER | SOCK_ISREUSE)); // 监听套接字初始化
    ret = m_epoll.Add(*m_server, EpollData((void*)m_server), EPOLLIN | EPOLLERR); // 监听套接字挂树
    ret = m_thread.Start(); // 开启线程来使用epoll_wait()等待事件产生
    return 0;
}

// 4.写日志
void WriteLog(const Buffer& data) {
	FILE* pFile = m_file; // 在后续的操作中使用临时指针 pFile，以避免直接操作成员变量
	fwrite((char*)data, 1, data.size(), pFile); // para1:写入数据的起始地址 para2:每次写入数据大小 para3:数据长度 para4:文件指针
	fflush(pFile); // 刷新文件缓冲区，确保数据被立即写入到文件中，而不是暂时存储在缓冲区中等待写入
}

// 5.静态成员方法，用于其他进程or线程通过本地套接字连接日志服务器并发送日志
static void Trace(const LogInfo & info) { // 给其他非日志进程的进程和线程使用的 可以通过类名+作用域符来调用  CLoggerServer::Trace()
    static thread_local CSocket client; // 连接套接字 one thread one connection
    if (client == -1) { // 静态的但每个线程(static thread_local)调这个函数都会构造一个新的 client 即一个线程对应一个客户端
        client.Init(CSockParam("./log/server.sock", 0)); // 指定本地日志服务器套接字路径
        client.Link(); // 客户端Link 即accept
    }
    client.Send(info); // 如果该线程已经和日志服务器建立了连接，直接发送即可
}
```

**日志的设计**：

设定了五个**日志等级**：`LOG_INFO`信息，`LOG_DEBUG`调试，`LOG_WARNING`警告， `LOG_ERROR`错误，`LOG_FATAL`致命

统一了**日志格式**为：源文件名 + 行号 + 日志等级 + 当前时间 + 所在函数 +进程ID + 线程ID +  自定义日志内容

日志类中重载了三个构造函数和`<<`运算符以支持**普通日志**、**流式日志**、**十六进制日志**

结合宏定义能很方便地给日志服务器发送不同类型的日志

**日志类**：

```C++
// 成员变量：
bool bAuto; // 默认是false 流式日志，则为true
Buffer m_buf; // 存储日志信息的字符串缓冲区

// 模版函数 重载输出操作符<< 以支持流式日志
template<typename T> 
LogInfo& operator<<(const T& data) { // 要输出的数据
    std::stringstream stream; // 用于将各种数据转换为字符串
    stream << data; // 利用 << 操作符将 data 写入流中
    m_buf += stream.str().c_str(); // 将流中数据转为字符串，并追加到 m_buf 
    return *this; // 返回对象，以支持链式调用：a << b << c
}

// 构造函数：
// 1.普通日志
LogInfo::LogInfo(
	const char* file, int line, const char* func,
	pid_t pid, pthread_t tid, int level,
	const char* fmt, ...
)
{
	char* buf = NULL;
	bAuto = false;
	// 将固定内容写到日志（文件名、行号、日志级别、时间、进程id、线程id、函数名）
	int count = asprintf(&buf, "%s(%d):[%s][%s]<%d-%d>(%s) ", 
		file, line, sLevel[level],							  
		(char*)CLoggerServer::GetTimeStr(), pid, tid, func);
	
	// 将可变参数列表(即日志内容)写到buf
	va_list ap; 
	va_start(ap, fmt); // 将 ap 初始化为参数列表的起始位 fmt 是日志格式字符串，用于确定可变参数的位置。
	count = vasprintf(&buf, fmt, ap); // 将参数列表中的可变参数格式串化为字符，并将结果保存到 buf 中
	if (count > 0) {
		m_buf += buf;
		free(buf);
	}
	m_buf += "\n";
	va_end(ap); // 结束可变参数列表的访问
}

// 2.流式日志
LogInfo::LogInfo(const char* file, int line, const char* func, pid_t pid, pthread_t tid, int level)
{//自己主动发的 流式的日志 
	bAuto = true; // LogInfo退出作用域时，调用析构函数时 检测m_bool 如果为true 则调用 CLoggerServer::Trace(*this)发送
	// 这里只用写默认格式信息即可，剩下都通过`<<`来生成日志
	char* buf = NULL;
	int count = asprintf(&buf, "%s(%d):[%s][%s]<%d-%d>(%s) ",
		file, line, sLevel[level],
		(char*)CLoggerServer::GetTimeStr(), pid, tid, func);
}

// 3.十六进制格式化日志
略
```

**宏定义**：

```C++
#define TRACEI(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO, __VA_ARGS__))
#define TRACED(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG, __VA_ARGS__))
#define TRACEW(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING, __VA_ARGS__))
#define TRACEE(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR, __VA_ARGS__))
#define TRACEF(...) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL, __VA_ARGS__))

//LOGI<<"hello" << 10 <<"how are you"; // 流失日志在日志对象析构时通过判断 m_bool == true 来调Trace(）
#define LOGI LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO)
#define LOGD LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG)
#define LOGW LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING)
#define LOGE LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR)
#define LOGF LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL)

//内存导出
//00 01 02 65……  ; ...a……
#define DUMPI(data, size) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_INFO, data, size))
#define DUMPD(data, size) CLoggerServer::Trace(LogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_DEBUG, data, size))
#define DUMPW(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_WARNING, data, size))
#define DUMPE(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_ERROR, data, size))
#define DUMPF(data, size) CLoggerServer::TraceLogInfo(__FILE__, __LINE__, __FUNCTION__, getpid(), pthread_self(), LOG_FATAL, data, size))
```

## 客户端连接服务器(主模块) --- 单Reactor多线程 + 业务接口多态

**功能**：处理各个网络用户的连接请求(`connect`)， 将`accept`上来的连接套接字全部发送给业务子进程处理(客户端处理模块)

**组成**：监听套接字 + epoll + 线程池 + 子进程 + 客户端处理模块的接口 

```c++
// 成员变量
CSocketBase* m_server; // 主模块的监听套接字对象指针
CEpoll m_epoll; // 主模块的epoll
CThreadPool m_pool; // 线程池
CProcess m_process; // 子进程
CBusiness* m_business; // 业务接口 是一个基类指针，故利用继承来实现多态，你初始化时传什么业务接口对象给我，我的子进程就执行什么业务
```

**业务接口**：

```C++
class CBusiness // 客户端处理的接口类
{
public:
	// 1.不做具体的业务实现，但是业务实现需要继承该类
	// 2.接口层最大的作用就是解耦！这里就通过接口层解耦了网络通信(主模块)和业务实现，在主模块中不需要写任何业务实现的具体逻辑
	//   具体的业务实现(客户端处理)通过继承该接口类去做实现
	CBusiness() 
		: m_connectedcallback(NULL), m_recvcallback(NULL) 
	{}
	virtual int BusinessProcess(CProcess* proc) = 0; // 纯虚函数，由派生出的业务处理模块去实现
	template<typename _FUNCTION_, typename... _ARGS_> // 设置回调函数参考上文<<模板类>>支持任意参数
	int setConnectedCallback(_FUNCTION_ func, _ARGS_... args) {	
		m_connectedcallback = new CConnectedFunction<_FUNCTION_, _ARGS_...>(func, args...);
		if (m_connectedcallback == NULL) return -1;
		return 0;
	}
	template<typename _FUNCTION_, typename... _ARGS_>
	int setRecvCallback(_FUNCTION_ func, _ARGS_... args) {
		m_recvcallback = new CReceivedFunction<_FUNCTION_, _ARGS_...>(func, args...);
		if (m_recvcallback == NULL) return -1;
		return 0;
	}
protected: // 以下两个可调用对象，1->支持一个延迟传参(CSocketBase* pClient) 2->支持两个延迟传参(CSocketBase*, const Buffer&)
	CFunctionBase* m_connectedcallback; // 连接完成后的回调函数
	CFunctionBase* m_recvcallback; // 收到网络用户请求的回调函数
};
```

```C++
// 成员方法

int Init(CBusiness* business, const Buffer& ip, short port) // para1:业务接口
{   // 1.设置子进程(业务处理进程)入口函数 2.创建子进程 3.开启线程池 4.创建epoll 
	// 5.创建监听套接字 6.监听套接字挂树 7.给线程池派发任务
	m_business = business;
	// 由于BusinessProcess是类的一个成员函数，要给他一个类对象的this指针，且还是虚函数，传什么派生类的对象就会执行派生类的逻辑，这里还是多态
	m_process.SetEntryFunction(&CBusiness::BusinessProcess, m_business, &m_process); // 设置子进程的进程入口函数
	m_process.CreateSubProcess(); // 创建子进程
	m_pool.Start(2); // 主进程开启线程池
	m_epoll.Create(2); // 主进程的epoll
	m_server = new CSocket(); // 主进程的监听套接字(网络)
	m_server->Init(CSockParam(ip, port, SOCK_ISSERVER | SOCK_ISIP | SOCK_ISREUSE)); // 主进程监听套接字初始化[(socket() bind() listen()]
	m_epoll.Add(*m_server, (EpollData)((void*)m_server)); // 主进程监听套接字挂epoll树
	for (size_t i = 0; i < m_pool.Size(); i++) { // 主进程给线程池发送任务
		m_pool.AddTask(&CServer::ThreadFunc, this);
	}
	return 0;
}

int CServer::ThreadFunc()
{	// 1.多线程共享epoll树根 2.epoll_wait()，返回的事件只有accept()客户端的connect()
    // 3.accept()后得到与客户端的通信套接字对象 4.将通信套接字发送给子进程(业务处理) 
	EPEvents events;
	while ((m_epoll != -1) && (m_server != NULL)) {
		ssize_t size = m_epoll.waitEvents(events, 500);
		for (ssize_t i = 0; i < size; i++)
		{
			 // 主模块根本不处理客户端的收发，只负责连接客户端，得到通信套接字fd，然后交由子进程处理
			if (events[i].events & EPOLLIN) { // 发生可读事件 EPOLLOUT->可写 EPOLLRDHUP->对端关闭连接 EPOLLET->边缘触发
				CSocketBase* pClient = NULL; // 创建通信套接字对象
				ret = m_server->Link(&pClient); // accept 同时初始化了通信套接字对象(二级指针出参)
				m_process.SendSocket(*pClient, *pClient); // 将通信套接字及其地址发送给子进程 主模块只负责处理连接，后续的通信一概不管
			}
		}
	}
	return 0;
}
```

## 客户端处理进程(业务模块)

**功能**：接收客户端连接服务器(父进程)发来的连接套接字，处理连接套接字上发生的I/O事件(主要包括**连接回调** + **接收回调**)

**组成**：epoll + 线程池 + 数据库 继承自客户端处理的接口类**CBusiness**

```c++
// 成员变量
CEpoll m_epoll; // 客户端处理模块的epoll,用于监听连接套接字的I/O事件
CThreadPool m_pool; // 线程池，用于处理网络用户的I/O请求
std::map<int, CSocketBase*> m_mapClients; // 套接字与套接字对象映射表 就是管理客户端处理模块的通信套接字呗 
unsigned m_count; // 客户端处理模块的线程个数
CDatabaseClient* m_db; // 数据库
protected: // 继承自业务接口基类
	CFunctionBase* m_connectedcallback; // 连接完成后的回调函数
	CFunctionBase* m_recvcallback; // 收到网络用户请求的回调函数
```

```C++
// 成员方法
// 1.连接回调函数
int Connected(CSocketBase* pClient) {
    //客户端连接服务器(主进程)发来了连接套接字， 简单打印一下客户端信息
    sockaddr_in* paddr = (sockaddr_in*)*pClient;
    TRACEI("client connected addr %s port:%d", inet_ntoa(paddr->sin_addr), paddr->sin_port);
    return 0;
}
// 2.接收回调函数 
int Received(CSocketBase* pClient, const Buffer& data) {
	//TODO:主要业务，在此处理 即客户端处理进程中，线程池(子线程)干的事
	// 01.HTTP 解析
	Buffer response = "";
	ret = HttpParser(data); // 1.解析Http请求 2.处理登录 3.查询数据库检查登录请求
	// 02.验证结果的反馈， 即发送http响应包给用户
	response = MakeResponse(ret); // 响应包
	ret = pClient->Send(response);
	return 0;
}
// 3.客户端处理进程的具体业务(对业务接口类中业务处理这一纯虚函数的重写)
virtual int BusinessProcess(CProcess* proc) {
    // 1.连接数据库并创建表 2.设置连接回调函数&接收回调函数 3.创建epoll树根 
	// 4.启动线程池 5.给线程池中的所有子线程分配任务ThreadFunc
	// 5.将连接服务器(主进程)发来的通信套接字挂树(自己的epoll树) 6.调用连接回调函数
	using namespace std::placeholders;
	m_db = new CMysqlClient(); // 初始化数据库
	KeyValue args; // 连接数据库需要的数据
	args["host"] = "10.170.141.3";
	args["user"] = "Yyh";
	args["password"] = "123456";
	args["port"] = 3306;
	args["db"] = "Yyh";
	m_db->Connect(args); // 连接数据库
	edoyunLogin_user_mysql user; // 新表
	m_db->Exec(user.Create()); // 创建表
	// 下面的见上文《模板类》
	setConnectedCallback(&CEdoyunPlayerServer::Connected, this, _1); // 设置连接回调函数(传this，因为Connected()是一个成员函数 _thiscall)
	etRecvCallback(&CEdoyunPlayerServer::Received, this, _1, _2); // 设置接收回调函数 std::placeholders_1/_2 都是占位符 告诉可变参数的模版函数，我还没有确定参数是什么，但是位置先占好
	m_epoll.Create(m_count); // 创建epoll树根(eventpoll)
	m_pool.Start(m_count); // 启动线程池
	for (unsigned i = 0; i < m_count; i++) { // 给线程池所有线程分派任务
		ret = m_pool.AddTask(&CEdoyunPlayerServer::ThreadFunc, this);
	}
	int sock = 0;
	sockaddr_in addrin; // 用于存放主模块发来的客户端地址
	while (m_epoll != -1) { // 将主模块发来的通信套接字挂树
		proc->RecvSocket(sock, &addrin); // 接收主模块发过来的与网络用户的通信套接字及其地址
		CSocketBase* pClient = new CSocket(sock); // 根据通信套接字新建套接字对象
		pClient->Init(CSockParam(&addrin, SOCK_ISIP));
		m_epoll.Add(sock, (EpollData)(void*)pClient); // 通信套接字挂树，注意是挂在客户端处理模块的epoll树上
		(*m_connectedcallback)(pClient); // 连接回调 打印主进程(服务器)发给我们的连上来的用户的ip和端口
	}
	return 0;
}

// 4.客户端处理进程的线程池中线程函数
int ThreadFunc() { 
	EPEvents events; // 1.线程池中的所有线程共享epoll树根 2.等待epoll上事件(网络用户套接字的可读事件)发生 3.调用接收回调函数
	while (m_epoll != -1) {
		ssize_t  size = m_epoll.waitEvents(events);
		for (ssize_t i = 0; i < size; i++)
		{
			if (events[i].events & EPOLLIN) { // 通信套接字上有可读事件
				CSocketBase* pClient = (CSocketBase*)events[i].data.ptr;
				if (pClient) {
					Buffer data;
					pClient->Recv(data); // 读内核接收缓冲区
					if (m_recvcallback) { // 需要接收回到
						(*m_recvcallback)(pClient, data); // 回调，验证登录+http响应
					}
				}
			}
		}
	}
	return 0;
}
```

## http解析

**功能**：解析客户端发来的HTTP请求、解析URL

**组成**：1.创建CHttpParser类来封装开源的、面向过程的 http_parser  2.创建UrlParser类来解析URL

**http_parser**:

```C++
// 使用http解析器 http_parser 的流程：
// 1.设置回调(callback)： http_parser_settings settings; settings.on_url = on_url; ...
// 2.定义并初始化解释器：http_parser parser; http_parser_init(&parser, HTTP_REQUEST);
// 3.解析： http_parser_execute(&parser, &settings, data, strlen(data)); 
// para1:http解析器实例的指针 para2：http_parser_settings结构体的指针，包含了解析器的配置和回调函数
// para3:待解析的数据的指针 para4:待解析的数据的长度 return：成功解析的数据长度
```

**CHttpParser**:

```C++
// 我们是如何将基于C语言的http_parser封装成面向对象的:
// 1.CHttpParser类中包含成员对象 http_parser 初始化时将http_parser.data 设置为当前类实例的this指针
// 2.http_parser_settings中的回调函数声明为静态函数，同时声明对应的成员函数
// (由于回调需要是静态函数或标准调用函数，C++中不能用标准调用函数作为类的成员函数，故只能通过静态函数来设置)
// 3.回调函数内(参数都会有一个http_parser*)，通过http_parser*->data 得到this指针
// 4.再用this指针调用对应的成员函数,将解析值赋给类的成员变量

//成员函数：
size_t Parser(const Buffer& data); // 解析函数，调用http_parser_execute, 解析http请求(data)
static int OnMessageBegin(http_parser* parser); // http 解析开始时的事件
// para1:指向当前HTTP解析器实例的指针 para2:指向包含URL的字符串的指针。这个指针指向原始输入数据的某个位置 para3:表示URL字符串的长度
// para2和para3是解析器自己得到的，当解析器检测到请求行中的URL时，它会调用on_url回调函数，并传递当前解析器状态和URL数据
static int OnUrl(http_parser* parser, const char* at, size_t length); 
static int OnStatus(http_parser* parser, const char* at, size_t length); // para2：状态信息起始位置 para3：状态信息长度
static int OnHeaderField(http_parser* parser, const char* at, size_t length); // para2:头部字段名(即Key "Connection:")的起始位置 para3:头部字段名长度
static int OnHeaderValue(http_parser* parser, const char* at, size_t length); // para2:头部字段值(即Value "Keep-Alive")的起始位置 para3:头部字段值长度
static int OnHeadersComplete(http_parser* parser); // 头部(header)解析完成时的事件
static int OnBody(http_parser* parser, const char* at, size_t length); // para2:body起始位置 para3:body长度
static int OnMessageComplete(http_parser* parser); // http 解析完成时的事件
```

## mysql封装---实现对象关系映射(ORM)

**功能**：封装mysql，实现**对象关系映射**

**组成**：列 -> 表 -> 库

**列类**: `_ mysql_field_`

```C++
// 成员变量
Buffer Name; // 名称
Buffer Type; // 类型
Buffer Size; // 数据库SQL语句中用的到size
unsigned Attr; // 属性：唯一性、主键、非空...
Buffer Default; // 默认值
Buffer Check; // 约束条件

unsigned Condition; // 操作条件 SQL_INSERT->插入 SQL_MODIFY->修改 SQL_CONDITION->条件 这三种操作的组合
union {
    bool Bool;
    int Integer;
    double Double;
    Buffer* String;
}Value; // 列的值
int nType; // 列的值的类型
```

```C++
// 为属性和操作以及值类型构建了枚举类型（位掩码），`|`按位或来设置，`&`按位与来判断
enum { // 标志位
	SQL_INSERT = 1,//插入的列
	SQL_MODIFY = 2,//修改的列
	SQL_CONDITION = 4//查询条件列
};

enum { // 标志位(列属性) 
	NONE = 0,
	NOT_NULL = 1, // 非空
	DEFAULT = 2, // 默认
	UNIQUE = 4, // 唯一
	PRIMARY_KEY = 8, // 主键
	CHECK = 16, // 约束
	AUTOINCREMENT = 32 // 自动增长
};

using SqlType = enum { // 列的数据类型
	TYPE_NULL = 0, // 空类型
	TYPE_BOOL = 1, 
	TYPE_INT = 2,
	TYPE_DATETIME = 4, // 日期时间类型 
	TYPE_REAL = 8, // 小数类型
	TYPE_VARCHAR = 16,
	TYPE_TEXT = 32,
	TYPE_BLOB = 64 // 字符串
};
```

```c++
// 成员方法：
// 1.列定义(返回对应的SQL语句)
virtual Buffer Create(); // eg: `id` INT NOT NULL AUTO_INCREMENT  `name` VARCHAR(255) NOT NULL DEFAULT "default_name"  这些语句用于创建表
// 2.根据str设置列的值
virtual void LoadFromStr(const Buffer& str); // 用于获取结果集时，将结果集中的值赋给结果表对应的列
// 3.where 语句使用的:生成等于表达式
virtual Buffer toEqualExp() const; // eg:SELECT * FROM table WHERE column_name = value DELETE FROM table WHERE column_name = value
// 4.值转字符串
virtual Buffer toSqlStr() const; // 将字段的值转字符串用于插入表的语句 INSERT INTO 表全名 (列名,...)VALUES(值,...)； 这里就是为了得到值
// 5.重载类型转换，获取列的全名
virtual operator const Buffer() const; // eg: `id`
```

**表类**: `_ mysql_table_`

```C++
// 成员变量 
Buffer Database; // 表所属的DB的名称
Buffer Name; // 表名
FieldArray FieldDefine; // 表的所有列对象指针
FieldMap Fields; // 列名及其列对象指针的映射表
```

```C++
// 成员方法
// 1.返回创建表的SQL语句 放到数据库类的exec()中去执行，才能实现创建表，这个函数本身并不是创建表
// CREATE TABLE table_name (column1 datatype constraints, column2 datatype constraints, ... primary key(column_name));
virtual Buffer Create(); // eg:CREATE TABLE `Persons` ( `ID` INTEGER NOT NULL AUTO_INCREMENT, ..., PRIMARY KEY (`ID`));
// 2.删除表(返回对应的SQL语句)
virtual Buffer Drop(); // eg:DROP TABLE `Persons`;
// 3.增删改查(返回对应的SQL语句)
virtual Buffer Insert(const _Table_& values); // eg: INSERT INTO `Persons` (`ID`) VALUES (123);
virtual Buffer Delete(const _Table_& values); // eg: DELETE FROM `Persons` WHERE `ID` = 123;
virtual Buffer Modify(const _Table_& values); // eg: UPDATE `Persons` SET `ID`=456 WHERE `ID` = 123;
virtual Buffer Query(const Buffer& condition); // eg:SELECT `ID` FROM `Persons` WHERE 'ID' = 123;
// 4.通过拷贝构造创建当前表对象的一个副本  
virtual PTable Copy() const; //  每次遍历结果集的一行数据时，都会调用 Copy() 来创建一个新的表对象副本，然后根据查询结果填充这个副本的列值
virtual void ClearFieldUsed(); // 清空表的所有列的标志(插入、修改、查询条件) 这些标志是在main中设置的 eg:value.Fields["user_qq"]->Condition = SQL_MODIFY;
```

**数据库类**: `CMysqlClient`

```c++
// 成员变量
MYSQL m_db; // MYSQL 结构体，表示一个 MySQL 连接对象
bool m_bInit;// 默认是false 表示没有初始化 初始化之后，则为true，表示已经连接
```

```c++
// 成员方法：
// 1.连接 KeyValue 是一个string->string的map，记录了"host" "user" "password" "db" "port"等参数用于连接数据库
virtual int Connect(const KeyValue& args); // call: mysql_real_connect() 
// 2.执行 sql 即要执行的 mysql 语句
virtual int Exec(const Buffer& sql); // call: mysql_real_query()
// 3.带结果的执行 sql 即要执行的 mysql 语句 Result是一个表指针列表，存放结果集 table用来存储每一行的查询结果然后放入Result中
// 4.call:mysql_real_query() mysql_store_result() mysql_num_fields() mysql_fetch_row()
virtual int Exec(const Buffer& sql, Result& result, const _Table_& table); 
// 5.开启事务
virtual int StartTransaction(); // call：mysql_real_query(&m_db, "BEGIN", 6);
// 6.提交事务
virtual int CommitTransaction(); // call：mysql_real_query(&m_db, "COMMIT", 7);
// 7.回滚事务
virtual int RollbackTransaction(); // call：mysql_real_query(&m_db, "ROLLBACK", 9);
// 8.关闭连接
virtual int Close(); // call：mysql_close(&m_db);
// 9.是否连接
virtual bool IsConnected();
```

**宏定义**：简化创建表对象和列对象的操作

```c++
#define DECLARE_TABLE_CLASS(name, base) class name:public base { \
public: \
virtual PTable Copy() const {return PTable(new name(*this));} \
name():base(){Name=#name;

#define DECLARE_MYSQL_FIELD(ntype,name,attr,type,size,default_,check) \
{PField field(new _mysql_field_(ntype, #name, attr, type, size, default_, check));FieldDefine.push_back(field);Fields[#name] = field; }

#define DECLARE_TABLE_CLASS_EDN() }};
```

![image-20240608202222289](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745030.png) 

上面的语句展开后：

![image-20240608202247911](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745032.png) 

继承`_mysql_table_`创建了一个表类，表中有四个列对象

## MD5加密

**功能**：网络客户端 MD5(时间，密钥，密码，盐)得到**数字签名**，再将 **时间 + 盐 + 用户名 + 数字签名** 做http请求发送给服务器 (密码没有传输)

​			服务器这边收到后，查数据库得到该用户名的密码，然后MD5(时间，密钥，密码，盐)得到哈希值，比较**哈希值与数字签名是否匹配**，匹配则登录验证成功

![image-20240608205236703](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745033.png) 

![image-20240608205304531](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745034.png) 

# 远控项目复盘

## 服务器---未重构

#### 单例模式---用于服务器网络通信套接字类

- **定义**：是一种软件设计模式，其核心思想是确保**类在应用程序的生命周期内只有一个实例**，并提供一个**全局的访问点**。这意味着无论何时何地请求这个类的实例，都将**返回相同的对象**。单例模式通常用于管理全局资源、共享配置信息、或者提供唯一的访问点来控制某些资源

- **实现**：1. 私有化它的构造析构函数  2.使用类的私有静态指针变量指向类的唯一实例  3.使用一个公有的静态方法获取该实例

  ```c++
  class CServerSocket
  {
  public:
  	static CServerSocket* getInstance() { // 3. 使用一个公有的静态方法获取该实例
  		if (m_instance == NULL) {
  			m_instance = new CServerSocket();
  		}
  		return m_instance;
  	}
  private:
  	CServerSocket() {} // 1. 私有化单例类的构造与析构函数
  	~CServerSocket() {} 
  	static CServerSocket* m_instance; // 2. 私有静态指针变量指向单例类的唯一实例
  };	
  ```

- **分类**：1.**懒汉式**：第一次使用时才初始化，延迟初始化  2. **饿汉式**：类产生时就初始化好了

  ```c++
  CServerSocket* CServerSocket::m_instance = NULL; // 懒汉式
  CServerSocket* CServerSocket::m_instance = new CServerSocket(); // 饿汉式 
  ```

- **问题**：

  1. **内存泄漏**：当单例是类实例指针时，由于将**析构函数声明为私有**，无法通过 **delete** 来调用析构函数释放在**堆区的资源**
  2. **线程安全**：
     a. 饿汉单例模式在程序**一开始就初始化好实例**，所以后续**不再需要考虑线程安全**的问题，故适用于线程比较多的程序中，以空间换取时间
     b.  懒汉式单例模式是一种**延迟实例化**的单例模式，在首次使用时才会创建实例。然而，懒汉式单例模式在**多线程环境下可能存在线程安全问题**，在懒汉单例模式中，如果多个线程同时检查实例是否已经创建，并且都发现实例尚未创建，那么它们都会尝试创建一个新的实例。这可能导致多个线程创建了多个实例，违反了单例模式的原则（多线程下的**竞态条件**）

```c++
// 内存泄漏的解决：
// 方法1：在类中再写一个主动释放资源的方法，声明为公有静态，然后手动调用该方法来释放资源
static void releaseInstance()
{
    if (m_instance != NULL)
    {
        CServerSocket* tmp = m_instance;
        m_instance = NULL;
        delete tmp;
    }
}

// 方法2：定义一个内部嵌套垃圾回收类(这也是我们在这个项目中采用的方法)
class CHelper
{ 	// CHelper 类是一个嵌套类（nested class），它被声明为 CServerSocket 类的私有内部类
    public:
    CHelper() // 嵌套类，可以访问 CServerSocket 类的私有成员
    {        
        CServerSocket::getInstance();
    }
    ~CHelper() 
    {		  
        CServerSocket::releaseInstance();
    }
};

static CHelper m_helper; // 定义一个内部类的静态对象 当该对象销毁的时候，调用析构函数顺便销毁单例对象 m_instance

// 方法3：智能指针 + 自定义删除器
```

- **适用场景**: 懒汉模式适用于线程比较少的场景，因为线程一旦多，加锁的开销就会体现出来；饿汉模式适用于线程比较多的场景，它会占用全局静态区一定的空间，但是能够确保只有一个实例。

### 数据包的封装设计

![image-20240613170205288](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847940.png) 

- 成员变量：

![image-20240613170437525](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847941.png) 

- 成员函数：

![image-20240613170943216](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847942.png) 

```c++
// 01.组包，用于把要发送的数据封装成包发送  input: 命令 + 字符串指针 + 长度 output: CPacket 对象
CPacket(WORD nCmd, const BYTE* pData, size_t nSize) // para1：命令  para2：数据指针  para3：数据大小
{
    sHead = 0xFEFF;
    nLength = nSize + 2 + 2; // 命令2 + 包数据nSize + 和校验2
    sCmd = nCmd;
    if (nSize > 0)
    {
        strData.resize(nSize);
        memcpy((void*)strData.c_str(), pData, nSize); // 拷贝数据
    }
    else
    {
        strData.clear(); // 无数据清空
    }

    sSum = 0;
    for (size_t j = 0; j < strData.size(); j++) // 计算校验位
    {
        sSum += BYTE(strData[j]) & 0xFF;
    }
}
```

```c++
// 02.解包，将从客户端收到的包中的数据分配到成员变量中
CPacket(const BYTE* pData, size_t& nSize) // para1：数据指针 para2：数据大小 输入时 nSize 代表这个包有多少个字节的数据，输出时返回的 nSize 代表我们在解包过程中用掉了多少个字节
{
    size_t i = 0; // 遍历数据包
    for (; i < nSize; i++)
    {
        if (*(WORD*)(pData + i) == 0xFEFF) // 识别包头 通过强转来控制每次读取的字符数量
        {
            sHead = *(WORD*)(pData + i); // 取包头
            i += 2; // WORD 为无符号短整型，占两个字节,取出包头后遍历指针 i 后移两位 
            break;
        }
    }
    if (i + 4 + 2 + 2 > nSize) // 包数据可能不全，即连 包头i + 长度4 + 命令2 + 校验2 都不全
    {
        nSize = 0;
        return; // 解析失败
    }

    nLength = *(DWORD*)(pData + i); i += 4; // 读包的长度
    if (nLength + i > nSize) // 当未完全接收
    {
        nSize = 0;
        return; // 解析失败
    }

    sCmd = *(WORD*)(pData + i); i += 2; // 读取命令

    if (nLength > (2 + 2)) // 数据的长度大于 命令2 + 校验2 说明这个包中有要读取的数据
    {
        strData.resize(nLength - 2 - 2); // 设置 string 的大小
        memcpy((void*)strData.c_str(), pData + i, nLength - 4);  // 读取数据
        i += nLength - 2 - 2; // 读取完数据后移动遍历指针 i 到最新的位置(此时移动到校验码开始的位置)
    }

    sSum = *(WORD*)(pData + i); i += 2;  // 读校验码
    WORD sum = 0;
    for (size_t j = 0; j < strData.size(); j++)
    {
        sum += BYTE(strData[j]) & 0xFF;
    }

    if (sum == sSum) // 校验
    {
        nSize = i; // 头 + 长度 + 命令 + 数据 + 校验   nSize 是以引用(&)的方式传参，这里返回的 nSize 代表解包过程中用掉了多少数据
        return;
    }

    nSize = 0;
}
```

- 文件信息结构体：

![image-20240613171138690](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847943.png) 

- 鼠标操作结构体：

![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406131847944.png) 

### 服务器的main()

**初始化套接字 -> 接收客户端连接请求 -> 接收并解析客户端的消息,返回客户端的控制命令 -> 根据控制命令执行相应的业务逻辑 -> 若有需要则返回消息给客户端**

- **查看磁盘分区**

```c++
// 查看本地磁盘分区 -> 创建磁盘分区的信息 -> 打包成数据包 -> 发送
_chdrive(i); 					          // 切换当前的驱动器，若切换成功说明服务器有这个磁盘
string += ('A' + i - 1); 		          // 得到盘符
CPack pack(string); 					  // 打包
CServerSocket::getInstance()->Send(pack); // 发送
```

- **查看指定目录下的文件**

```c++
// 客户端发路径过来 -> 切换到指定路径 -> 循环遍历文件 -> 发送
_chdrive(path); // 切换到指定路径
while (!_findnext(_1, _2)){} // 用于在文件系统中查找文件或目录并获取下一个匹配项的信息 _1:当前文件句柄 _2:结构体指针，存储下一个匹配项信息
```

- **运行文件**

```c++
// 客户端发路径过来 -> 系统调用打开改文件
ShellExecute(_...); // 用于启动或打开外部应用程序或文件
```

- **下载文件**

```c++
// 客户端发路径过来 -> 打开文件 -> 得到当前文件大小 -> 发送文件大小给客户端 -> 发送文件
fopen(path, "rb");  // 二进制只读打开
fseek(_1, _2, _3);  // _1:文件指针 _2:偏移量 _3:将文件指针指向某个位置，这里指向尾
_ftelli64(pFile);   // 获取当前文件位置指针的偏移量，从而得知文件的大小，先发送文件大小给客户端
fseek(_1, _2, _3);  // 文件指针复原回文件头
while() {fread();}  // 将文件指针指向的数据以数据流的方式读取到目标缓冲区，每次循环都会发送
```

- **删除文件**

```c++
// 客户端发路径过来 -> 删除文件 -> 发送应答包告诉客户端已删除成功
DeleteFile();
```

- **鼠标操作**

```c++
// 客户端发鼠标操作(左右键、单双击、鼠标坐标) -> 根据鼠标操作组合(|)一个状态位掩码 -> 根据状态位掩码调用相关的WindowsAPI -> 发送应答包告诉客户端操作成功
nflag = nButton, nflag |= nAction; // 根据发来的鼠标操作组合状态位掩码
SetCursorPos(x, y); 			   // 根据发来的鼠标坐标设置本地鼠标位置
mouse_event(); 					   // Windows 系统中模拟鼠标操作的 API 函数
```

- **发送屏幕截图**

```c++
// 创建CImage -> 调API拿屏幕上下文与属性 -> 设置CImage并将当前屏幕复制给它 -> 创建全局堆+内存流 -> 保存图像到内存流中 -> 发送
CImage screen;            // 创建 CImage 对象
::GetDC(); 				  // 拿到屏幕上下文 
GetDeviceCaps();          // 拿到屏幕属性
BitBlt();  			      // 把图像复制到 screen 中，相当于截图
GlobalAlloc();  		  // 创建全局堆
CreateStreamOnHGlobal();  // 创建内存流
screen.Save();  		  // 保存图像到内存流中
```

- **锁机**

```c++
// 开启线程执行锁机函数 -> 创建占满屏幕的锁机对话框 -> 将锁机dlg设置为最上层 -> 限制鼠标活动范围 -> 隐藏鼠标光标和任务栏 -> 开启消息循环直到收到解锁消息
_beginthreadex();  		// 开启锁机线程
dlg.Create(); 	    	// 创建锁机对话框
dlg.SetWindowPos(); 	// 设置为最上层
ShowCursor();			// 隐藏鼠标
ClipCursor(); 	        // 限制鼠标方位
while (GetMessage())    // 开启消息循环直到收到别的线程发过来的解锁消息或者主动按下 ESC
{
    TranslateMessage();
    DispatchMessage();
     // 在消息循环中检测是否有键盘按键(ESC)按下，并在检测到按键按下时销毁对话框并结束消息循环，从而终止程序执行
}
```

- **解锁**

```c++
// 给锁机线程发送一个 ESC 按下的消息
PostThreadMessage(); // 用于将消息放入指定线程的消息队列中
```

## 服务器---第一次重构

### 重构思路

从上面的整理可以看出来，我们在 `main.cpp`中创建套接字对象(**CServerSocket**)，接收来自客户端的消息，然后执行命令后立即将对应的应答发送给客户端，这样就将**业务的处理与网络的通信耦合在一起了**，我们希望业务处理与网络通信相互独立，以提高这两个模块的**可移植性**。故我们的==**优化思路**==：解耦业务处理与网络通信，通过引入一个 **CCommand** 类来执行命令处理(业务逻辑)，而 **CServerSocket** 类只负责收发数据包(通信)

1. `main()` 中声明一个通信类的对象(**CServerSocket**)，一个业务处理类的对象(**CCommand**)
2. `main()` 中调用通信类对象的 `Run() `函数，将业务处理对象的**处理函数指针及这个对象**作为参数传入
3. `Run()` 中初始化网络连接，解析客户端发来的命令包，然后**回调业务处理模块的处理函数**，传入命令包、应答包`list`
4. 业务处理模块根据传入的命令包执行对应的业务逻辑，完成后需要发送的应答包存在 `list` 中
5. 通信模块将应答包 `list` 发给客户端

即，

**重构前**：通信模块接收命令包 -> `main()` 中执行业务处理 -> 在业务处理后**立即发送**应答包    			  **将命令处理+应答包发送视为一次完整的业务流程，耦合**

**重构后**：通信模块接收命令包 -> 通过**回调**让业务处理模块执行对应的业务 -> 通信模块发送应答包 ,	**将命令处理视为一次完整业务流程，解耦**

### 通信模块

```c++
// *******************************通信模块*******************************
// 该函数是服务端核心入口函数，用于对外使用的接口
// 其做出以下几个响应动作：
// ①初始化网络库，即调用InitSocket()
// ②连接客户端，即调用AcceptClient()
// ③处理客户端发来的数据，返回命令，即调用DealCommand()
// ④将命令交给Command类对象，回调，让其完成命令操作
// ⑤从成员lstPackets表中取得从Command处理后的数据(功能函数push_back的数据，参考Command类的功能函数)，然后调用Send发送回客户端
// para1:CCommand业务处理函数指针 para2:执行命令的对象，即Command对象 para3:端口号，默认9527 返回值：失败返回-1
int Run(SOCKET_CALLBACK callback, void* arg, short port = 9527)
{
    m_callback = callback; // 等下要回调的业务处理函数
    m_arg = arg; 		   // 业务处理对象
    std::list<CPacket> lstPackets; // 存储 CPacket 对象的双向链表容器
    bool ret = InitSocket(port); // 网络初始化

    while (true)
    {
        int ret = DealCommand(); // 解析命令 (recv())
        // 这个回调函数 m_callback() 即CCommand里面的RunCommand()
        // para1:CCommand类对象的 this 指针 para2:命令 
        // para3:应答包，存储数据包的容器，命令处理过程中但凡有数据包要发送给客户端，就会将这个包添加到容器中
        // para4:命令包，数据处理过程中需要用到的客户端发来的数据(如文件路径、鼠标事件等)
        // 解耦之前：命令处理过程中涉及到的网络通信工作都在处理命令的同时完成
        // 解耦之后：通过para3和para4，命令处理过程中只需要处理数据，网络通信工作全部交由CServerSocket负责
        m_callback(m_arg, ret, lstPackets, m_packet); // 将命令交给Command类对象m_arg， 相关的功能执行后返回的数据包会加到lstPacket尾部
        while (lstPackets.size() > 0) // 服务端有数据包要发送给客户端
        {
            Send(lstPackets.front()); // 发送数据包（解耦之前是在命令执行过程中完成的）
            lstPackets.pop_front(); // 在容器中删除发送的数据包
        }
    }
    return 0;
}
```

### 业务处理模块

```c++
// *******************************业务处理模块*******************************
static void RunCommand(void* arg, int status, std::list<CPacket>& lstPacket, CPacket& inPacket) // 静态，对外给CServerSocket类使用
{ 
    thiz->ExcuteCommand(status, lstPacket, inPacket); // 调用业务处理模块的成员函数来执行业务处理
}
// 参数 2 3 的用处：为了解耦命令处理与网络通信过程，将网络通信的相关工作全部交由CServerSocket处理
// 原来耦合的逻辑：在处理命令时，使用socket接收客户端传来数据包->处理命令->使用socket发送处理后的数据包，将命令的处理与应答包的发送视为一次完成的
// 解耦后的逻辑：传来的数据包和要发送的数据包全部以参数的形式处理，在执行命令过程中不再接收/发送数据，也就不涉及到网络通信了,只关心数据的处理
// para1:命令 para2:应答包list para3:命令包
int ExcuteCommand(int nCmd, std::list<CPacket>& lstPacket, CPacket& inPcaket); // 执行命令	
{
	std::map<int, CMDFUNC>::iterator it = m_mapFunction.find(nCmd); // 找命令对应的业务处理函数
	// 通过业务处理函数指针调用执行对应命令的处理函数(函数的逻辑同解耦前，不过不需要发送应答包，而是添加到应答包list)
	return (this->*it->second) (lstPacket, inPacket);
}
typedef int(CCommand::* CMDFUNC)(std::list<CPacket>&, CPacket& inPacket); // 业务处理函数指针取别名 CMDFUNC
std::map<int, CMDFUNC> m_mapFunction; // 命令与业务处理函数指针的映射表 可以使用命令作为键来检索对应的业务处理函数指针
// 重构前用的 switch case 逻辑，最多支持255个，且查询速度慢(O(n))  用 map，增删改查方便，都是O(1)
```

## 服务器---第二次重构

### 重构思路

之前的方式服务器(被控方)发送与客户端(控制方)通信是同步阻塞的，在发送大文件或屏幕截图时十分影响效率，故决定引入 windows 下的异步模型 **IOCP**

### IOCP

**IOCP（I/O Completion Port，I/O完成端口）**是性能最好的一种**基于事件驱动**的 I/O 模型。IOCP 简单的说明就是创建专用的 I/O 线程，该线程负责与所有客户端进行**异步 I/O**，内核将 I/O 完成后发送通知到完成队列，用户从完成队列获取已完成的 I/O 事件执行后续的操作，与 epoll 不同，此时数据**已经从内核态拷贝到了用户态，用户态这边无需再 `recv()`，以实现真正的异步通信**。往往结合一个**工作者线程池**使用，工作线程负责从完成队列中取得数据进行后续操作。工作者线程池可以限制线程的数量以避免创建太多 thread 而导致在切换线程时浪费大量的时间(**空间换时间**)。

**流程：**

1. 创建 IOCP (`CreateIoCompletionPort()`), 创建 IOCP 线程，在线程中循环调用 `GetQueuedCompletionStatus()`来得到已完成的 I/O 结果
2. 创建工作者线程池，该线程池中的线程用以从完成队列中取得用户态的数据(由于是异步，完成队列有消息时说明数据已达用户态)进行后续的处理
3. 创建一个用于监听的 Socket(`WSASocket()`)，绑定到完成端口上(`CreateIoCompletionPort()`)，然后开始在指定的端口上监听连接请求
4. 在这个监听Socket上投递异步连接请求`AcceptEx()`, 用户收到完成通知时，将得到的连接套接字也注册绑定到完成端口上(`CreateIoCompletionPort()`)
5. 某个连接套接字需要向 IOCP 投递异步 I/O 请求：投递收请求---`WSARecv()`， 投递发请求---`WSASend()`
6. 投递连接请求时给的重叠结构(`overrlapped`)，里面可以放自定义的数据，包括对应 I/O 请求的回调函数指针等等，就是靠这个重叠来区分是哪一个套接字上完成的哪一个I/O 事件

**类比**：

1. `GetQueuedCompletionStatus()`就有点类似`epoll_wait()`，不过前者是 I/O 已完成，后者还需要用户态向内核态读/写
2. `CreateIoCompletionPort()`就有点类似`epoll_create()`和`epoll_ctl()`, 创建完成端口以及将套接字绑定到完成端口，但`epll_ctl()`还注册了事件
3. `AcceptEx()`、`WSARecv()`、`WSASend()`就有点类似于`epoll_ctl()`的注册事件
4. `overlapped`就有点类似于`epoll_event`，都可以放自定数据，从内核返回用户态时，在用户态用以区分

### 线程池的设计

```c++
// 1. 定义线程函数基类，用户通过继承这个类来自定义不同的线程函数 (实际的处理函数指针在 Overlapped 结构中，线程池中的线程拿到这个重叠结构后执行其中的函数)
// 2. 定义工作线程类，其成员为线程函数基类对象，在其中重载函数调用运算符`()`让其成为一个函数对象
// 3. 定义线程类，其成员为工作线程类对象，抽象出启动、停止、更新、是否有效、是否空闲等接口，方便线程池调用
// 4. 定义线程池类，其成员为工作线程对象指针数组，抽象出启动、停止、分发任务等接口，注意分发任务时需要 std::mutex 上锁，来保证多线程下任务分发的同步互斥
```

### 服务器的设计

```c++
// 1. 创建服务器监听套接字
void CEdoyunServer::CreateSocket()
{
    WSADATA WSAData;
    WSAStartup(MAKEWORD(2, 2), &WSAData); // 向操作系统说明，我们要用哪个库文件，从而就可以调用该版本的socket的各种函数
    m_sock = WSASocket(PF_INET, SOCK_STREAM, 0, NULL, 0, WSA_FLAG_OVERLAPPED); // 创建带有重叠 I/O（Overlapped I/O）特性的监听套接字
	bind();
    listen();
}
// 2. 创建 IOCP 并将监听套接字绑定到 IOCP 上(有点类似epoll中将套接字挂树) 然后向 IOCP 投递异步连接请求
m_hIOCP = CreateIoCompletionPort(INVALID_HANDLE_VALUE, NULL, 0, 4);  // 创建IOCP
CreateIoCompletionPort((HANDLE)m_sock, m_hIOCP, (ULONG_PTR)this, 0); // 监听套接字绑定到 IOCP 上
// 投递异步连接请求
// para1:服务器socket，用于监听连接请求 para2:用于接收连接的socket para3:接收缓冲区 para4：para3中用于存放数据的空间大小
// para5:存放本地址地址信息的空间大小 para6:存放本远端地址信息的空间大小 para7：接收到的数据大小 para8：本次重叠I/O所要用到的重叠结构
AcceptEx(m_sock, *pClient, *pClient, 0, sizeof(sockaddr_in) + 16, sizeof(sockaddr_in) + 16, *pClient, *pClient); // 并不会真的accept() 而是投递异步连接请求给IOCP，IOCP 处理完后可以从连接队列中渠道

// 3. 开启线程池，开启 IOCP 线程用以监听完成队列，取出已完成的 I/O 请求，根据重叠结构中成员去分发线程执行对应的后续处理
int CEdoyunServer::threadIocp()
{
    DWORD transferred = 0;
    ULONG_PTR CompletionKey = 0;
    OVERLAPPED* lpOverlapped = NULL;
    // 监控完成端口,监视完成端口的队列中是否有完成的网络操作 (有点类似 epoll_wait)
    // para1:建立的那个唯一的完成端口 para2:操作完成后返回的字节数 para3:自定义结构体参数 para4:重叠结构 para5:等待完成端口的超时时间
    if (GetQueuedCompletionStatus(m_hIOCP, &transferred, &CompletionKey, &lpOverlapped, INFINITE))
    {   // AcceptEx WSARecv WSASend 都会向相关socket绑定的完全端口投递异步 IO 请求
        if (CompletionKey != 0)
        {
            // 重叠结构我们就可以理解成为是一个网络操作的ID号，也就是说我们要利用重叠I/O提供的异步机制的话，每一个网络操作都要有一个唯一的ID号，（其实就是重叠结构里面的各种成员）
            // 因为进了系统内核，里面黑灯瞎火的，也不了解上面出了什么状况，一看到有重叠I/O的调用进来了，就会使用其异步机制，
            // 并且操作系统就只能靠这个重叠结构带有的ID号来区分是哪一个网络操作了，然后内核里面处理完毕之后，根据这个ID号，把对应的数据传上去。
            EdoyunOverlapped* pOverlapped = CONTAINING_RECORD(lpOverlapped, EdoyunOverlapped, m_overlapped); // 通过重叠结构，拿到了重叠结构的父对象的指针
            pOverlapped->m_server = this;
            switch (pOverlapped->m_operator)
            {
            case EAccept: // 处理连接请求
            {
                ACCEPTOVERLAPPED* pOver = (ACCEPTOVERLAPPED*)pOverlapped; 
                m_pool.DispatchWorker(pOver->m_worker); // 分配线程处理连接请求，后续的函数指针已经放在了重叠结构中，有点类似回调
            }
            break;
            case ERecv:
            {
                RECVOVERLAPPED* pOver = (RECVOVERLAPPED*)pOverlapped;
                m_pool.DispatchWorker(pOver->m_worker); // 分配线程处理接收请求
            }
            break;
            case ESend:
            {
                SENDOVERLAPPED* pOver = (SENDOVERLAPPED*)pOverlapped;
                m_pool.DispatchWorker(pOver->m_worker); // 分配线程处理发送请求
            }
            break;
            case EError:
            {
                ERROROVERLAPPED* pOver = (ERROROVERLAPPED*)pOverlapped;
                m_pool.DispatchWorker(pOver->m_worker); // 分配线程处理报错请求
            }
            break;
            }
        }
        else
        {
            return -1;
        }
    }
    return 0;
}

// 4. 以连接请求为例
AcceptEx(); // 向 IOCP 投递异步连接请求
GetQueuedCompletionStatus(); // 拿到完成的 I/O
case EAccept: // 通过重叠结构来判断完成的I/O属于哪个套接字上的哪个事件
{  
    ACCEPTOVERLAPPED* pOver = (ACCEPTOVERLAPPED*)pOverlapped;
    m_pool.DispatchWorker(pOver->m_worker); // 通过重叠结构中的回调指针来执行后续处理
}
```

### UDP 穿透

https://blog.csdn.net/qq_40989769/article/details/135003318

![image-20240617152920235](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240230.png)    

![image-20240617152945894](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240231.png) 

 ### NAT 

**定义** ：NAT（Network Address Translation，网络地址转换）是一种网络技术，它允许**多个设备在同一公共IP地址下共享一个网络连接**。NAT在路由器或防火墙上执行，它能够**将私有IP地址转换为公共IP地址**，从而使得私有网络中的设备能够与外部网络（如互联网）进行通信

**主要作用**：

1. 节省公共IP地址: NAT允许多个设备使用一个公共IP地址与外部网络通信，这大大节省了公共IP地址的使用量，解决了IPv4地址不足的问题
2. 隐私和安全性: NAT隐藏了内部网络结构，因为外部设备只能看到NAT设备的公共IP地址，而看不到内部网络的私有IP地址。这增加了内部网络的安全性和隐私保护
3. 灵活的网络管理: NAT可以使网络管理更加灵活，便于对内部网络进行重新配置而不影响与外部网络的连接

**原理**：当内部网络的设备向外部网络发送请求时，NAT设备会**修改数据包的源IP地址和源端口号，将它们替换为NAT设备的公共IP地址和相应的端口号**。同时，NAT设备会在内部维护一个映射表，记录私有IP地址和端口号与公共IP地址和端口号的对应关系。返回的数据包则会根据这个映射表进行转换，将目的IP地址和端口号替换为内部设备的私有IP地址和端口号。





# 计算机网络

## HTTP/HTTPS

```c++
// 1. http 与 https 的区别及其各自优缺点？
```

==**区别**==： 

| http                                 | https                   |
| :----------------------------------- | ----------------------- |
| 明文传输，不安全（监听、篡改、劫持） | 密文传输+身份认证，安全 |
| port: 80                             | port: 443               |
| TCP握手                              | TCP握手 + SSL握手       |
| 无需向服务端申请证书                 | 需要到CA申请证书        |

==**优缺点**==：

|      | http                                                         | https                                                        |
| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 优点 | 简单、灵活、易扩展、应用广                                   | 1. 传输数据过程中，使用密钥对传输的数据进行**加密**，安全性较高<br />2. 可以对用户和服务器进行**认证**，确保了数据传送的完整性和准确性,保证信息不被窃听，篡改和劫持 |
| 缺点 | 以明文的方式在网络中传输数据，通信内容容易被**窃听、篡改、劫持**，无法保证数据的完整性和准确性，因此使用HTTP协议传输数据**不安全** | 1.HTTPS协议**握手阶段延时较高**： 由于在进行HTTP会话前，还需要进行**SSL握手**，所以HTTPS协议握手阶段延时会适当增加。<br />2.HTTPS协议**部署成本高**： 首先，HTTPS协议需要购买**CA证书**，通过证书来验证自身的安全性；其次，HTTPS属于加密传输协议，需要进行**加密、解密的计算与操作**，会占用一定数量的CPU资源，因此，需要的服务器配置、数目相对较高 |

```c++
// 2.请你描述一下从输入网址到网页完全打开的整个过程是怎样的?
```

| 1.DNS域名解析        | 客户端输入域名后，由DNS服务器来将域名解析成对应服务器的IP地址<br />解析顺序：浏览器缓存->系统缓存->本地DNS解析->根DNS解析->顶级DNS解析->权限DNS解析 |
| -------------------- | ------------------------------------------------------------ |
| 2.建立TCP连接        | 获得服务器IP之后，就需要**三次握手**的协议才能建立连接<br />①客户端发送SYN包请求 -> <br />②服务器确认收到SYN包请求同时自己返回一个包给客户端，即返回SYN+ACK -><br />③客户端收到SYN+ACK包之后，返回给服务器一个确认包 ACK 包表示收到，然后双方达成协议，建立连接<br />如果是HTTPS协议，还有**SSL**的握手 |
| 3.发送HTTP/HTTPS请求 | 与服务器建立连接之后，就可以向服务器发送请求包了，请求需要遵循http/https协议 |
| 4.服务器处理请求     | 被请求的服务器解析用户请求的有哪些资源，通过服务器返回数据(响应包)给客户端 |
| 5.返回响应结果       | 给客户端返回请求的状态码，通过状态码可以知道服务器端的处理是否正常。如果返回异常，就会展示对应的错误信息<br />`100 Continue` 客户端的部分请求已被接收，且仍未被拒绝<br />`200 OK` 请求成功，正常状态，表示服务器已成功处理了客户端的请求<br />`301 Moved Permanently`  请求的网页已永久移动到新位置<br />`400 Bad Request`  语义有误，当前请求无法被服务器理解。或者是请求参数有错误<br />`404 Not Found` 请求失败，资源不存在，可能是输入的URL错误或资源被删除or移动到其他位置<br />`500 Internal Server Error` 一般来说，这个问题都会在服务器端的源代码出现错误时出现、配置问题or资源不足 |
| 6.浏览器渲染         | 返回成功之后，浏览器拿到请求页面的代码，将其解析渲染出来。解析和渲染的过程主要由浏览器的渲染引擎实现 |
| 7. 断开连接          | 数据传输完毕，需要断开tcp连接，此时tcp发起4次挥手            |

```c++
// 3.HTTP报文的结构
```

**==请求报文==**：

![image-20240609140259619](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745035.png) 

![image-20240609140645433](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745036.png) 

**==响应报文==**：

![image-20240609140822118](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745037.png) 

![image-20240609140849779](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745038.png) 

```c++
// 4. http的keep-alive是如何实现？有什么用途？
```

**实现**：HTTP 的 **`Keep-Alive`** 是通过在 HTTP **请求头**中增加一个参数来实现的，这个参数是 **`Connection: keep-alive`**。当客户端和服务器之间的通信使用了Keep-Alive 参数时，它指示服务器在发送完响应后**保持 TCP 连接**打开状态，以便后续的请求可以继续复用这个连接，而不必每次都重新建立连接。

**用途**：

| 1.减少连接建立和断开开销 | 在传统的 HTTP 中，每次请求都需要建立一个新的 TCP 连接，完成请求后又需要断开连接。而使用 Keep-Alive 功能可以让客户端和服务器在一次连接中完成多个请求和响应，避免了重复的 TCP 连接的建立和断开过程，从而减少了连接的开销 |
| ------------------------ | ------------------------------------------------------------ |
| 2.提高性能和效率         | 减少了连接的建立和断开次数可以提高通信的效率和性能。特别是在一些高并发的场景下，使用 Keep-Alive 功能可以显著减少服务器的负担，提高了系统的吞吐量。 |
| 3.优化网络资源利用       | 使用 Keep-Alive 功能可以更有效地利用网络资源，减少了因频繁建立和断开连接而造成的网络资源浪费。尤其是在网络延迟较高的情况下，复用连接可以减少网络传输的等待时间，提高了网络资源的利用率。 |
| 4.改善用户体验           | 减少了连接的建立和断开次数可以加快页面加载速度，提高了用户访问网站的体验。特别是对于一些需要频繁请求资源的网页应用，使用 Keep-Alive 功能可以明显改善用户的响应速度和流畅度。 |

 

```C++
// 5.GET 和 POST 的区别
```

| GET的语义是从服务器获取指定的资源                            | POST 的语义是根据请求负荷（报文body）对指定的资源做出处理    |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| GET把请求的数据放在URL上，以`?`分割URL和传输数据，参数之间以`&`相连 | POST把数据放在HTTP的包体(报文body)内                         |
| GET产生**一个**TCP数据包，浏览器会把http header 和 data 一并发送出去，服务器响应 `200 OK`(返回数据) | POST产生**两个**TCP数据包，浏览器先发送header，服务器响应`100 Continue`,浏览器再发送data，服务器响应 `200 OK`(返回数据) |
| GET请求会被浏览器主动缓存                                    | POST请求不会被浏览器主动缓存                                 |
| GET是**幂等**的，即多次执行相同的操作，结果都是「相同」的    | POST**不是幂等**的                                           |

## TCP/IP

### 1.网络分层模型，各层的作用以及为什么要分层?

| 分层       | 作用                                                         | 常用协议         |
| ---------- | ------------------------------------------------------------ | ---------------- |
| 应用层     | 直接与用户交互，提供应用服务和网络应用的接口，不用去关心数据是如何传输的 | HTTP、FTP、DNS等 |
| 传输层     | 负责数据(Segments)的可靠传输，提供端到端的通信服务           | TCP、UDP         |
| 网络层     | 负责数据包(Packets)的路由选择和转发，实现不同网络之间的互联  | IP、ICMP、ARP    |
| 网络接口层 | 负责数据帧(Frames)的传输，确保在同一网络内的节点间可靠传输数据 | 以太网、Wi-Fi    |

为什么要分层：==**解耦并屏蔽底层细节**==
a. **简化复杂性**：分层将复杂的网络通信问题分解成更小的、易于管理的部分，每一层都只关注其特定的功能
b. **独立开发**：每一层的协议和实现可以独立开发和演化，而不需要改变其他层
c. **灵活性**：由于各层独立，新的协议和技术可以更容易地集成到现有的体系结构中。例如，可以在传输层引入新的传输协议，而无需改变应用层协议
d.**故障隔离**：如果网络通信出现问题，分层设计可以帮助快速定位问题所在的层，从而更有效地解决问题

### 2. TCP与UDP的区别？

| 区别               | TCP (Transmission Control Protocol)                          | UDP (User Datagram Protocol)                                 |
| :----------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 连接               | 面向连接的传输层协议，传输数据前先要建立连接                 | 不需要连接，即刻传输数据                                     |
| 服务对象           | 一对一的两点服务，即一条连接只有两个端点                     | 支持一对一、一对多、多对多的交互通信                         |
| 可靠性             | 可靠交付数据，数据可以无差错、不丢失、不重复、按需到达       | 尽最大努力交付，不保证可靠交付数据                           |
| 流量控制、拥塞控制 | 有拥塞控制和流量控制机制，保证数据传输的安全性               | 没有，即使网络非常拥堵了，也不会影响 UDP 的发送速率          |
| 首部开销           | 首部在没有使用「选项」字段时是 `20` 个字节，如果使用了「选项」字段则会变长的 | 首部只有 8 个字节，并且是固定不变的，开销较小                |
| 传输方式           | 流式传输，没有边界，但保证顺序和可靠                         | 一个包一个包的发送，是有边界的，但可能会丢包和乱序           |
| 数据包大小         | 数据大小如果大于 MSS 大小，则会在传输层进行分片，目标主机收到后，也同样在传输层组装 TCP 数据包，如果中途丢失了一个分片，只需要传输丢失的这个分片 | 数据大小如果大于 MTU 大小，则会在 IP 层进行分片，目标主机收到后，在 IP 层组装完数据，接着再传给传输层 |
| 应用场景           | FTP 文件传输 、 HTTP / HTTPS                                 | 视频流、在线游戏、实时语音（VoIP）、DNS查询                  |

### 3. TCP粘包问题？

**问题**：TCP粘包是指在使⽤TCP进行数据传输的过程中，发送⽅发送的多个数据包会被接收方⼀次性接收，导致多个数据包黏在⼀起，这通常是因为tcp的传输是基于**字节流**的，**不保证数据的边界**所引起的。多个应用层消息可能会被合并成一个TCP段发送，或一个应用层消息可能会被拆分成多个TCP段接收，这就导致了粘包

**原因**：

a. Nagle算法通过将小的数据包合并成一个较大的数据包发送，以减少网络上的小包数量。这种合并发送可能导致粘包。

b. 当发送的数据量较小时，TCP会尽可能地将多个小数据包合并成一个数据包发送，以提高网络利用率

c. 接收方从TCP缓冲区读取数据时，如果读取操作不够及时或一次性读取的数据量较大，可能会一次性读取多个应用层消息，导致粘包

**解决办法**：

a. 添加消息边界：在发送数据时，给数据包添加⼀个特殊的边界标识，比如换行符或特殊字符。接收方在接收数据时，根据数据标识堆数据包进行拆分。
b. 使用定长消息：约定每个数据包的长度固定。如果数据长度不足，那么就用特定字符去填写。这个方法适合于数据包长度固定的场景，但是可能会导致数据传输的效率降低。
c. 添加消息头：在发送数据的时候，为数据包添加⼀个消息头，在消息头中包含数据包的长信息。接收⽅在接收数据时，先解析消息头，获取数据包长度，然后根据长度对数据包进行拆分。
d. 使⽤应⽤层协议：使⽤HTTP或者FTP等协议，这些协议都已经解决了粘包问题

### 4. UDP会发生粘包吗？ UDP为什么会有乱序问题？ 为什么先发的包不会先到呢？

a. UDP本身不会发⽣粘包。UDP是基于数据报的协议，发送发的数据报时独⽴的，因此有明确的边界。当接收⽅收到UDP的数据报时，会根据数据报的边界进行数据处理，因此不会发⽣粘包

b. UDP中不像tcp中，有滑动窗口，序列号，确认应答和超时重传的机制，所以由于⽹络抖动等问题，数据包并不是按照先后顺序到达的，并且UDP本身没有做可靠传输的处理，所以使用UDP，会存在乱序问题，需要自己处理

c. 在数据包发送的过程中，数据包需要经过多个路由器和交换机才能到达目的地。这些设备会根据当前网络的网络状况和拥塞情况调整数据的路径。因此，及时从同⼀源地址发送到同⼀目的地址的两个数据包，它们的路径也不同，每条路径的拥塞情况，数据包丢失情况和重传情况都不同，所以它们的到达顺序可能会不同

### 5. TCP 3 次握手的过程？

a. 一开始，客户端和服务端都处于`CLOSE`状态，先是服务端主动监听某个端口进入`LISTEN`状态

b. 客户端会随机初始化序号（`client_isn`），将此序号置于 TCP 首部的「序号」字段中，同时把 `SYN` 标志位置为 `1`，表示 `SYN` 报文。接着把第一个 SYN 报文发送给服务端，表示向服务端发起连接，该报文不包含应用层数据，之后客户端处于 `SYN-SENT` 状态。

c. 服务端收到客户端的 `SYN` 报文后，首先服务端也随机初始化自己的序号（`server_isn`），将此序号填入 TCP 首部的「序号」字段中，其次把 TCP 首部的「确认应答号」字段填入 `client_isn + 1`, 接着把 `SYN` 和 `ACK` 标志位置为 `1`。最后把该报文发给客户端，该报文也不包含应用层数据，之后服务端处于 `SYN-RCVD` 状态

d. 客户端收到服务端报文后，还要向服务端回应最后一个应答报文，首先该应答报文 TCP 首部 `ACK` 标志位置为 `1` ，其次「确认应答号」字段填入 `server_isn + 1` ，最后把报文发送给服务端，这次报文可以携带客户到服务端的数据，之后客户端处于 `ESTABLISHED` 状态

e. 服务端收到客户端的应答报文后，也进入 `ESTABLISHED` 状态

### 6. 为什么要 3 次握手

a.  三次握手才能保证双方具有接收和发送的能力	

b. 三次握手才能同步双方的初始序列号

c.  **防止旧的重复连接初始化造成混乱**: 两次握手，服务器没有中间状态来给客户端阻止历史连接，导致服务端可能建立一个历史连接，浪费资源

![image-20240626193606996](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406262054220.png) 

### 7.建立TCP连接，后续如果数据包有损坏和乱序，是如何处理的？

| 异常    | 如何处理                                                     |
| ------- | ------------------------------------------------------------ |
| a. 损坏 | 在发送端，TCP 会计算发送数据的**校验和**存储在头部，如果数据包在传输过程中损坏（比如由于噪声、信号衰减等原因），接收端的 TCP 层会检测到校验和不匹配的情况。当接收到损坏的数据包时，TCP 不会通知应用层（例如浏览器或下载管理器），而是**直接丢弃**这个数据包，然后请求发送端**重新发送**丢失或损坏的数据。【重传机制下面会介绍】 |
| b.乱序  | TCP 使用**序列号和确认号**来对传输的数据包进行**排序和确认**，接收端会根据每个数据包的序列号（Sequence Number）来确认数据包的顺序。如果接收到的数据包不是按顺序到达的（即出现乱序），TCP 接收端会将乱序的数据包**缓存**起来，直到所有数据包都按正确的顺序到达。一旦所有数据包都到达并按顺序排列，TCP 协议会将这些数据包按序交付给应用层。 |

### 8. TCP 遇到网络拥塞或者大流量的情况如何去做？

| a. 拥塞检测    | TCP 通过丢包和超时来检测网络拥塞。当发生丢包(收到连续相同的ACK)时，TCP 会认为网络存在拥塞，并采取相应的拥塞控制策略 |
| -------------- | ------------------------------------------------------------ |
| b.拥塞控制策略 | 当检测到网络拥塞时，TCP 会降低发送速率，通过减小拥塞窗口大小来控制数据包的发送速率，以便减少对网络的负载。TCP 使用拥塞避免算法来逐步增加拥塞窗口的大小，但会避免过快地填充网络，从而降低出现拥塞的可能性 |
| c. 动态调整    | TCP 协议会根据网络状态实时动态调整拥塞窗口的大小和发送速率，以适应网络的变化，从而实现稳定的数据传输。总之就是**慢启动**、**拥塞避免**、**快恢复**等机制，以及拥塞窗口的动态调整，基于这些机制来保证传输的**可靠和稳定** |

### 9. TCP 重传机制？

| 重传机制                   | 方法                                                         | 关键                                                         |
| -------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| a. 超时重传                | 发送数据时，设定一个定时器，当超过指定的时间后，没有收到对方的 `ACK` 确认应答报文，就会重发该数据 | 确定超时重传时间(RTO)，如果超时时间**长了**，网络的空隙时间增大，降低了网络传输效率；如果**短了**，可能导致没有丢就重发，导致网络负荷增大。<br />==**超时重传时间 RTO 的值应该略大于报文往返 RTT 的值**== |
| b. 快速重传                | 以数据驱动重传，**三次同样**的`ACK`，就会触发重传            | ==**重传的时候，是重传一个，还是重传所有的问题**==。如果重传一个，效率很低，还要收到下一个的三次`ACK`才能触发重传。如果重传所有，有可能后面的是已经接收过的，浪费资源 |
| c. 选择性确认(`SACK`)      | 在 TCP 头部「选项」字段里加一个 `SACK` 的东西，它**可以将已收到的数据的信息发送给「发送方」**，这样发送方就可以知道哪些数据收到了，哪些数据没收到，知道了这些信息，就可以**只重传丢失的数据** |                                                              |
| d. 重复选择性确认(`D-ACK`) | 使用了 SACK 来告诉「发送方」有哪些数据被**重复接收**了       | 1. 可以让「发送方」知道，是发出去的包丢了，还是接收方回应的 ACK 包丢了; <br />2. 可以知道是不是「发送方」的数据包被网络延迟了; <br />3. 可以知道网络中是不是把「发送方」的数据包给复制了 |

### 10. TCP 流量控制？

- 窗口大小就是指**无需等待确认应答，而可以继续发送数据的最大值**
- TCP头部的 `Window` 字段：指定了窗口大小用于**接收端告诉发送端自己还有多少缓冲区可以接收数据**。发送端可以根据接收端的处理能力来发送数据，而不会导致接收端处理不过来，故TCP中窗口大小是由接收方的窗口大小决定的
- **滑动窗口**：发送但未收到`ACK`的数据都要缓存，直到收到对应的`ACK`后方可滑动窗口
- 如果发送方收到接收方窗口大小=0的`ACK`报文，就不会再发送数据，但会启动一个计时器，超时后发送**窗口探测报文**， 防止接收端的窗口通知报文丢失导致**死锁**
- **糊涂窗口综合症**：如果接收方腾出几个字节并告诉发送方现在有几个字节的窗口，而发送方会义无反顾地发送这几个字节，这就是**糊涂窗口综合症**。

```c++
// TPC + IP 头部至少有40字节，如果每次只为了传几个字节的数据，就很浪费
糊涂窗口综合症的原因：a. 接收方可以通告一个小的窗口 b. 而发送方可以发送小数据
解决方案：a. 让接收方不通告小窗口给发送方 b. 让发送方避免发送小数据

// 接收方:
窗口大小小于min(MSS, 缓存空间/2), 就会把窗口大小置0
// 发送方：
Nagle算法(延时处理): a. 要等到窗口大小 >= MSS 并且 数据大小 >= MSS  <or> b. 收到之前发送数据的 ack 回包
如果上面两个条件都不满足，发送方就会一直囤积数据
```

### 11. TCP 拥塞控制？

- **慢启动**：发送方每收到一个 `ACK`, 拥塞窗口`cwnd`大小`+1` (指数增长)

- **拥塞避免**：`cwnd` > `ssthresh`(慢启动门限,一般为`65535`)，就会进入拥塞避免，发送方每收到一 个`ACK`, 拥塞窗口`cwnd`大小`+1/cwnd` (线性增长)

- **超时重传的拥塞恢复**：`ssthresh` 设为 `cwnd/2`，`cwnd` 重置为初始值   eg：发生超时重传时，`cwnd=1000` ---> `cwnd=init, ssthresh=500`，然后**慢启动**

- **快速重传的拥塞恢复**：`cwnd = cwnd/2` ，也就是设置为原来的一半 ` ssthresh = cwnd `eg:`cwnd=1000` ---> `cwnd=500, ssthresh=500`,然后**快速恢复**

  a. 拥塞窗口 `cwnd = ssthresh + 3` （ 3 的意思是确认有 3 个数据包被收到了）

  b. 重传丢失的数据包

  c. 如果再收到重复的 ACK，那么`cwnd + 1`

  d. 如果收到新数据的 ACK 后，`cwnd = ssthresh` ，原因是该 `ACK `确认了新的数据，说明从` duplicated ACK `时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入**拥塞避免**状态；

### 12. TCP 四次挥手？

   ![image-20240614134459231](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406262054221.png)  

### 13. TCP 挥手丢失了会怎么样？

| 挥手次数       | 机制                                                         |
| -------------- | ------------------------------------------------------------ |
| 第一次挥手丢失 | 第一次挥手丢失了，那么客户端迟迟收不到被动方的 ACK(第二次挥手) ，就会触发超时重传机制，重传 FIN 报文，每次超时重传等待时间是上一次的两倍，达到最大重传次数后，如果还是没有收到服务端的第二次挥手，就直接进入 `close` 状态 |
| 第二次挥手丢失 | ACK 报文是不会重传的，所以服务端的第二次挥手丢失了，客户端就会触发超时重传机制，同第一次挥手丢失；<br /> |
| 第三次挥手丢失 | 服务端迟迟收不到客户端的 ACK(第四次挥手)，就会超时重传，达到最大重传次数后就`close`<br />注意如果客户端调用的是 `close()` 来关闭连接，`FIN_WAIT_2` 只会持续60秒，所以迟迟收不到第三次挥手的话，客户端也会`close` |
| 第四次挥手丢失 | ACK 报文是不会重传的，所以客户端的第四次挥手丢失了，服务端就会触发超时重传，一直收不到，达到最大重传次数就会进入`close`；客户端在收到第三次挥手并发送第四次挥手后，就会进入 `TIME_WAIT` 状态，开启时长为 2MSL 的定时器，如果途中再次收到第三次挥手（FIN 报文）后，就会重置定时器，当等待 2MSL 时长后，客户端就会断开连接 |

### 14.  为什么 TIME_WAIT 等待的时间是 2MSL？

**定义**：主动发起关闭的一方才会有 `TIME_WAIT` 状态，在收到第三次挥手和发送第四次挥手后，就会进入该状态,，时间为 2MSL，在收到第三次挥手的重传后该时间会重置

**为什么要有**: 

1. 防止历史连接中的数据，被后面相同四元组的连接错误的接收，2MSL 足以让两个方向上的数据包都被丢弃，使得原来连接的数据包在网络中都自然消失，再出现的数据包一定都是新建立连接所产生的
2. 等待足够的时间以确保最后的 ACK(第四次挥手) 能让被动关闭方接收，从而帮助其正常关闭，因为第四次挥手如果丢失了(1MSL)，服务端会重传第三次挥手(1MSL)，这样一来一回，刚好能保证服务端收到重传的第三次挥手

### 15. TIME_WAIT 过多有什么危害？

1. 占用系统资源，比如说文件描述符、内存资源、CPU资源、线程资源等
2. 占用端口资源，端口资源也是有限的
3. 还要考虑到主动断开连接的是哪一方
   - **服务器主动断开**：并不会导致端口资源受限，因为服务端只监听一个端口，而且由于一个四元组唯一确定一个 TCP 连接，因此理论上服务端可以建立很多连接，但是 TCP 连接过多，会占用系统资源，比如文件描述符、内存资源、CPU 资源、线程资源等
   - **客户端主动断开**：首先需要明白，客户端的端口是`connect()`之后，内核随机挑选的,但是一个端口号是可以**重用的**，因为TCP连接是依靠==[目的IP，目的端口，源IP，源端口]==这个四元组来唯一确定的，只要这其中一个变化，就可以建立新的连接。所以客户端的同一个端口是可以连接不同IP、不同端口的服务器的。因此，客户端（发起连接方）都是和**「目的 IP+ 目的 PORT 」都一样的服务端**建立连接(就需要使用客户端的端口来做区分了)的话，当客户端的 TIME_WAIT 状态连接过多的话，就会受端口资源限制，如果占满了所有端口资源，那么就无法再跟「目的 IP+ 目的 PORT」都一样的服务端建立连接了。

### 16. 如何避免 TIME_WAIT？

- `TIME_WAIT`设计出来肯定是有其作用的，如清空历史连接中的数据，让被动关闭方更优雅地关闭，可以服务端永远不要主动断开连接，让客户端去断开，由分布在各处地客户端去承受 `TIME_WAIT`

```c++
// 15.服务器出现大量 TIME_WAIT 状态的原因有哪些？
```

明确，`TIME_WAIT` 是只有==**主动断开连接**==的一方才有的状态

1. ==HTTP 没有使用长连接(`Keep-Alive`)== 如果要关闭长连接，需要在 HTTP 请求或响应包中添加 `Connection:close` 信息，也就是说，只要客户端和服务端任意一方的 HTTP header 中有 `Connection:close` 信息，那么就无法使用 HTTP 长连接的机制。关闭长连接机制后，每次请求都要经历这样的过程：**建立 TCP -> 请求资源 -> 响应资源 -> 释放连接**，那么此方式就是 **HTTP 短连接**。因此，**当服务端出现大量的 TIME_WAIT 状态连接的时候，可以排查下是否客户端和服务端都开启了 HTTP Keep-Alive**，因为任意一方没有开启 HTTP `Keep-Alive`，都会导致服务端在处理完一个 HTTP 请求后，就主动关闭连接，此时服务端上就会出现大量的 `TIME_WAIT` 状态的连接。针对这个场景下，解决的方式也很简单，让客户端和服务端都开启 HTTP Keep-Alive 机制
2. ==HTTP 长连接超时== 如果现象是有大量的客户端建立完 TCP 连接后，很长一段时间没有发送数据，那么大概率就是因为 HTTP 长连接超时，导致服务端主动关闭连接，产生大量处于 TIME_WAIT 状态的连接
3. ==HTTP 长连接的请求数量达到上限==

```c++
// 16.服务器出现大量 CLOSE_WAIT 状态的原因有哪些？
```

明确，`CLOSE_WAIT` 是只有==**被动断开连接**==的一方才有的状态。而且如果「被动关闭方」没有调用 `close()` 函数关闭连接，那么就无法发出 FIN 报文，从而无法使得 `CLOSE_WAIT` 状态的连接转变为` LAST_ACK` 状态。所以，**当服务端出现大量 CLOSE_WAIT 状态的连接的时候，说明服务端的程序没有调用 close 函数关闭连接**。   (注意，TCP三次握手的建立和`accept()`没有关系，内核已经处理好了，`accept()`只是用于从全连接队列取出建立好的连接罢了)

1. 没有将监听套接字注册到 epoll ，导致新连接到来了服务端收不到事件通知，自然也就无法`accept()`，获取不到通信套接字，自然也就无法调用`close()`
2. 没有调用 `accept()` 接收连接
3. 没有将 `accept()` 上来的通信套接字注册到 epoll ,自然也就无法得知客户端断开连接事件
4. 没有调用 `close()` 或者代码卡在哪里，死锁了

```c++
// 17. 如果已经建立连接，但是客户端突然出现故障了怎么办？
```

客户端出现故障指的是客户端的主机发生了宕机，或者断电的场景。发生这种情况的时候，如果服务端一直不会发送数据给客户端，那么服务端是永远无法感知到客户端宕机这个事件的，也就是服务端的 TCP 连接将一直处于 `ESTABLISH` 状态，占用着系统资源。

- TCP 的==**保活机制**== ：定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。但是需要等待的时间比较长
- 自己在应用层实现==**心跳机制**==：比如，web 服务软件一般都会提供 `keepalive_timeout` 参数，用来指定 HTTP 长连接的**超时时间**。如果设置了 HTTP 长连接的超时时间是 60 秒，web 服务软件就会**启动一个定时器**，如果客户端在完成一个 HTTP 请求后，在 60 秒内都没有再发起新的请求，**定时器的时间一到，就会触发回调函数来释放该连接**

```c++
// 18. TCP 一定不会丢包吗？
```

TCP 通过序列号、确认应答、重传机制来保证**传输层**的可靠性(只保证 A 的传输层到  B 的传输层不会丢包)，当数据包到了接收方的传输层接收缓冲区时，内核协议栈就会回一个 ACK，发送方收到这个包的 ACK 后，就从自己的发送缓冲区将这个包丢掉，至此 TCP 的任务已经结束。
但再往上，它**并不能保证应用层的可靠性**，交给应用层时若出现内存不足闪退等情况，数据就会丢失。在实际应用中，开发者需要自己来保证应用层的可靠性，这包括了消息缓存和重传机制，以及确保数据在成功到达目标后被正确处理等方面。因此，为了实现应用层的可靠性，通常会使用消息队列、持久化存储(磁盘)等技术。

# 操作系统 

## 进程&线程

### 进程和线程的区别？

| 本质区别：         | 进程是==资源分配==的基本单位                                 | 线程是==CPU调度==的基本单位                                |
| ------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 并发性(切换效率)： | 低：CPU寄存器、程序计数器、用户空间的信息(虚拟内存)内核空间的数据(pcb) | 高：CPU寄存器、程序计数器(**同一进程下的线程之间**)        |
| 内存：             | 进程有==独立的==虚拟地址空间(进程之间运行环境是相互==隔离==的) | 线程==共享==进程的虚拟地址空间，有栈、程序计数器等独立空间 |
| 所属关系：         | 一个进程可以拥有多个线程                                     | 一个线程必须依附于一个进程存在                             |
| 健壮性：           | 高：进程有独立的运行环境(**本质原因**)，一个进程宕机了不会影响其他进程 | 低：一个线程发生异常，同一进程下的所有线程都会宕掉         |

### 进程和线程切换的区别？

**上下文切换的过程**：

1. 保存当前进/线程的硬件上下文(寄存器状态、当前运行的指令)于内核中
2. .修改当前进/线程的PCB(TCB)，修改运行状态(阻塞/就绪)， 存储管理数据的保存 
3. 修改被调度进/线程的PCB(TCB)，将状态修改为运行 
4. 存储管理数据的切换 5.恢复硬件上下文，让程序计数器(PC)执行被调度的进程代码

**区别**：主要是上文过程中 **2、4 **(前提是同进程下的线程，如果是不同进程下的线程那切换就和进程切换一样了)

- 进程需要切换地址空间，线程不需要  

- 进程切换开销较大，需要保存和恢复大量上下文信息(寄存器、页表、fd) 线程切换开销较小，只需要保存和回复少量的上下文信息(寄存器)

### 什么时候会发生切换？

| 1. 时间片耗尽（时间片轮转调度）                        | 在多任务操作系统中，时间片轮转（Round-Robin）是一种常用的调度算法。每个线程被分配一个固定的时间片（时间段）来运行。当时间片耗尽时，操作系统会挂起当前线程并调度下一个线程运行 |
| ------------------------------------------------------ | ------------------------------------------------------------ |
| 2. I/O 操作（阻塞）                                    | 当一个线程执行 I/O 操作（例如读写文件、网络通信等）时，它通常会被阻塞，等待 I/O 操作完成。在这段等待时间里，操作系统会挂起该线程并调度其他线程运行 |
| 3. 线程主动让出 CPU                                    | 线程可以通过调用诸如 yield、sleep 或 wait 等方法主动让出 CPU，允许操作系统调度其他线程运行 |
| 4. 线程优先级调度                                      | 操作系统通常会根据线程的优先级来进行调度。当一个高优先级的线程变得可运行时，操作系统可能会中断当前低优先级线程的执行，并调度高优先级线程运行 |
| 5. 线程结束                                            | 当一个线程完成其任务并终止时，操作系统会进行线程切换，调度另一个线程运行 |
| 6. 锁和同步机制                                        | 线程在访问共享资源时通常会使用锁或其他同步机制（如信号量、条件变量等）来避免竞争条件。当一个线程尝试获取一个已被其他线程持有的锁时，它会被阻塞，直到锁被释放。操作系统在这种情况下会调度其他可运行的线程 |
| 7.硬件中断（如定时器中断、I/O 中断等）也会导致线程切换 | 操作系统响应中断后，可能会改变当前线程的运行状态，从而调度其他线程运 |

### 什么时候会发生用户态和内核态的切换？ 

a.  系统调用：当用户态程序需要执行某些需要操作系统协助完成的操作时，如文件操作、网络请求等，就需要通过系统调用进入内核态

b.  异常处理：当用户态程序出现异常，如非法操作、除零错误等，处理器会自动切换到内核态以处理异常

c.  外部中断：当硬件设备发生中断，如键盘、网卡等发出中断请求，CPU响应中断，切换到内核态执行中断处理程序

反过来就是内核态切换到用户态了，比如：系统调用完成、异常处理完成...

### 进程调度算法

| 算法               | 做法                                                         |
| ------------------ | ------------------------------------------------------------ |
| 1.先来先服务       | 非抢占式的调度算法，按照请求的顺序进行调度。有利于长作业，但不利于短作业，因为短作业必须一直等待前面的长作业执行完毕才能执行，而长作业又需要执行很长时间，造成了短作业等待时间过长 |
| 2.短作业优先       | 非抢占式的调度算法，按估计运行时间最短的顺序进行调度。长作业有可能会饿死，处于一直等待短作业执行完毕的状态。因为如果一直有短作业到来，那么长作业 永远得不到调度。 |
| 3.最短剩余时间优先 | 最短作业优先的抢占式版本，按剩余运行时间的顺序进行调度。 当一个新的作业到达时，其整个运行时间与当前进程的剩余时间作比较。如果新的进程需要的时间更少，则挂起当前进程，运行新的进程。否则新的进程等待。 |
| 4.时间片轮转       | 将所有就绪进程按 FCFS 的原则排成一个队列，每次调度时，把 CPU 时间分配给队首进程，该进程可以执行一个时间片。如果时间片太小，会导致进程切换得太 频繁，在进程切换上就会花过多时间；如果时间片过长，那么实时性就不能得到保证退化成了先来先服务 |
| 5.优先级调度       | 为每个进程分配一个优先级，按优先级进行调度                   |
| 6.多级反馈队列     | 时间片轮转调度算法和优先级调度算法的结合。设置了多个队列，每个队列时间片大小都不 同，例如 1,2,4,8,..。进程在第一个队列没执行完，就会被移到下一个队列 |

### 进程间通信(IPC)方式?

| 方式         | 做法                                                         | 特点                                                       |
| ------------ | ------------------------------------------------------------ | ---------------------------------------------------------- |
| 1.匿名管道   | 半双工的通信方式，数据只能单向流动，就是两个进程通过操作系统提供的内存空间进行通信，以**无格式的字节流**的形式传输数据  `pipe()` | 单向、只能用于父子进程间通信、数据先进先出                 |
| 2.命名管道   | 同上，在文件系统中以特殊文件形式存在 `mkfifo()`              | 单向、可用于两个独立进程间通信、数据先进先出               |
| 3.消息队列   | 消息队列实际上是保存在内核的「消息链表」，消息队列的消息体是可以用户自定义的数据类型(克服了管道传输的数据类型问题)，发送数据时，会被分成一个一个独立的消息体 `msgget()` | 数据有大小限制、数据的读写需要经过用户态和内核态的拷贝过程 |
| 4.共享内存   | 直接分配一个共享空间，每个进程都可以直接访问， 不需要陷入内核态或者系统调用，大大提高了通信的速度`shmget()` | 最快、多线程的竞态条件，涉及同步互斥                       |
| 5.信号量     | 信号量其实是一个计数器，表示的是资源个数，其值可以通过两个原子操作来控制，分别是 P 操作和 V 操作`sem_init()` | 实现共享资源的互斥访问与线程间的同步                       |
| 6.信号       | 异步通信机制，信号可以在应用进程和内核之间直接交互，内核也可以利用信号来通知用户空间的进程发生了哪些系统事件 `signal()` | 异步通知                                                   |
| 7.本地套接字 | 采用套接字通信机制，支持TCP/UDP协议  `socket(PF_LOCAL, SOCK_STREAM, 0)`<br />https://www.zhihu.com/question/43590414 | 编程复杂度高、结合epoll实现高效并发处理且无需考虑同步互斥  |

### 线程间同步互斥的方式？

| 方式     | 特点                                                         | 应用场景                                                     |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 原子操作 | 原子操作是一种保证**不会被中断**的操作，可以确保多个线程同时对共享变量进行读取、修改和写入操作时的一致性 | 适用于简单的**共享数据**操作，例如==计数器或标志位==，不需要复杂的锁机制。它们可以避免锁的开销，提高性能 |
| 信号量   | 信号量是一个**计数器**，用于控制多个线程对共享资源的访问。信号量包括两种类型：二进制信号量（只能取值 0 或 1，类似于互斥锁）和计数信号量（可以取任意非负整数值） | 用于控制对**资源的访问**，可以限制同时访问资源的线程数量。适用于需要限制资源访问数量的情况：==限制连接数、资源配额管理、多线程限流==， |
| 自旋锁   | 基于**忙等待**的锁，它在尝试获取锁时会反复检查锁的状态，加锁失败后，线程会**忙等待**，直到成功获取锁或者超 | 被锁住的代码**执行时间很短**                                 |
| 互斥锁   | 确保**同一时间只有一个线程**可以访问共享资源。当一个线程获取了互斥锁后，其他线程需要等待锁被释放才能继续执行 | 用于保护临界区，防止多个线程同时修改==共享数据==             |
| 递归锁   | 允许**同一个线程多次获取锁而不会导致死锁**。它解决了传统互斥锁在递归调用或循环中反复获取同一个锁时可能导致死锁的问题，维护了⼀个锁计数器和⼀个拥有锁的线程标识 | ==递归函数、类的成员函数调用的相互调用、多次进入临界区==     |
| 读写锁   | 允许多个线程同时读取共享资源，但只允许一个线程写入共享资源。当有线程在写入时，其他线程无法读取或写入，但可以等待  **读共享，写独占** | 适用于**读操作频繁而写操作较少**的情况:==缓存读取、数据库查询、配置文件读取== |
| 条件变量 | 条件变量允许线程在**不满足特定条件时挂起等待，在条件满足时被唤醒继续执行**。条件变量通常**与互斥锁一起使用**，以确保在修改共享数据时不会出现竞态条件 | ==生产者消费者模型、任务队列==                               |
| 屏障     | 让一组线程等待，直到所有线程都达到同步点后再继续执行         | 需要协调多个线程在某个点之前都完成特定工作再继续的场景：==并行计算中的阶段同步、多线程任务同步、协同并行处理== |

### 自旋锁与互斥锁

**==阻塞==**：线程在等待某个条件满足（如获取锁、等待 I/O 完成、等待信号等）时，主动**放弃 CPU 使用权，并进入睡眠状态**。当条件满足时，线程被**唤醒**并重新调度执行，不会占用CPU资源

**==忙等==**：忙等是指线程在等待某个条件满足时，**不进入睡眠状态**，而是不断循环检查条件是否满足，**持续占用 CPU 资源，不会切换线程状态**

|          | 自旋锁                                                       | 互斥锁                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 加锁失败 | 线程会**忙等待**，直到它拿到锁                               | 线程会**释放 CPU** ，给其他线程；互斥锁是一种「独占锁」，比如当线程 A 加锁成功后，此时互斥锁已经被线程 A 独占了，只要线程 A 没有释放手中的锁，线程 B 加锁就会失败，于是就会释放 CPU 让给其他线程，既然线程 B 释放掉了 CPU，自然线程 B 加锁的代码就会被**阻塞**；加锁失败后，内核会将线程置为「睡眠」状态，等到锁被释放后，内核会在合适的时机**唤醒**线程，当这个线程成功获取到锁后，于是就可以继续执行； |
| 开销     | 通过 CPU 提供的 `CAS` 函数（*Compare And Swap*），在「用户态」完成加锁和解锁操作，不会主动产生线程上下文切换 | 互斥锁加锁失败时，会从用户态陷入到内核态，让内核帮我们**切换线程**，产生**两次线程上下文切换**的成本    运行 -> 睡眠(阻塞)                       睡眠(阻塞)->就绪 |
| 优点     | 低上下文切换开销、实现简单                                   | 不占用CPU资源、容易使用                                      |
| 缺点     | 高CPU占用、不适合长期持锁，如果临界区代码执行时间长，会影响程序的响应性和并发性 | 上下文切换开销                                               |
| 使用时机 | 短时间持锁(自旋时间与临界区代码执行时间成正比)；异步、协程等在用户态切换请求的编程方式 | 长时间持锁、单核系统(单核CPU下如果不抢占式地调度，自旋锁永远不会放弃CPU) |

### 悲观锁与乐观锁

悲观锁和乐观锁是两种不同的并发控制策略，用于处理多线程环境下对共享资源的访问。它们的主要区别在于对并发冲突的处理方不同

|          | 悲观锁                                                       | 乐观锁                                                       |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 特点     | 采取悲观的态度，认为在任何时候都会发生并发冲突。因此，在访问共享资源之前，它会先获取锁，然后在临界区内执行操作，最后释放锁 | 采取乐观的态度，认为在大多数情况下不会发生并发冲突。因此，在访问共享资源之前，它不会加锁，而是直接进行操作。只有在更新操作时才会检查是否发生了冲突 |
| 冲突处理 | 自旋锁、互斥锁、读写锁                                       | 版本号、时间戳<br/>每次操作都会将当前版本号或时间戳与原始值进行比较，如果相同则说明没有发生并发冲突，可以继续操作；如果不同则说明发生了冲突，需要进行**回滚或重试**操作 |
| 适用场景 | 写操作频繁、并发度低的情况，对数据一致性要求较高             | 读操作频繁、并发度高的情况，对性能要求较高                   |

### 死锁

- **定义**：当两个或多个线程互相等待对⽅释放资源时，就可能发⽣死锁。这会导致线程⽆法继续执⾏，程序陷⼊⽆响应状态
- **发生条件**：1.互斥资源，多个线程不能使用同一个资源 2

1. **互斥**，多个线程不能使用同一个资源
2. **持有并等待**：线程 A 在等待资源 2 的同时并**不会释放**自己已经持有的资源1
3. **不可剥夺**：当线程已经持有了资源 ，在自己使用完之前**不能被其他线程获取**
4. **环路等待**：死锁发生的时候，**两个线程获取资源的顺序构成了环形链**

![image-20240615150653158](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406151508192.png) 

- **如何避免**：使用**资源有序分配法**，来破坏**环路等待**条件

![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406151508734.png)  

## 内存管理

### 为什么要使用虚拟内存？

**a. 内存隔离和保护**： 虚拟地址允许每个进程都有自己的地址空间，使得多个进程可以同时运行而互不干扰。每个进程都认为它在独立的内存空间中运行，因此不会直接访问其他进程的内存。这种隔离性可以提高系统的安全性和稳定性，防止程序之间相互干扰或滥用内存。

**b.地址空间扩展**： 虚拟地址使得操作系统可以在有限的物理内存资源下支持更多的进程运行。每个进程都可以有自己的地址空间，即使物理内存有限，也可以通过页面交换等技术将不活跃的页面存储到磁盘上，从而实现更大的地址空间。

**c.内存映射和共享**： 虚拟地址使得操作系统可以更灵活地管理内存，实现内存的映射和共享。例如，多个进程可以映射同一个文件到它们的地址空间中，实现文件共享的功能

**d.地址重定位**： 虚拟地址允许操作系统在程序加载时将程序的地址空间映射到物理内存上的不同位置，从而提高系统的安全性和可移植性。这种地址重定位技术使得程序可以在不同的系统上运行而无需修改，提高了程序的可移植性和兼容

总的来说，虚拟地址提供了更高的安全性、稳定性和灵活性，使得操作系统可以更有效地管理内存资源，提高系统的性能和可用性

### 内存是如何分布的？ 

| 分区                 | 特点                                                         |
| -------------------- | ------------------------------------------------------------ |
| text（代码段）       | 存储的是程序源代码编译后的机器指令，是只读的                 |
| rodata（只读数据段） | 存放的是程序中的只读数据，⼀般是程序⾥⾯的只读变量和字符串常量，还有虚表 |
| data（数据段）       | 存放的是已经初始化了的全局静态变量和局部静态变量             |
| bss                  | 存放的是未初始化的全局静态变量和局部静态变量                 |
| 堆                   | ⼀般由程序员分配释放， 若程序员不释放，存放⼀些new创建出来的对象 |
| 栈                   | 由编译器⾃动分配释放 ，存放函数的参数值，局部变量的值等      |
| 内核空间             | 是操作系统内存管理的⼀部分，用于存储和运行操作系统内核的代码和数据 |

![image-20240610141638172](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121744430.png) 

### 栈区和堆区的区别？

| 区别               | 堆                                                           | 栈                                                           |
| ------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 内存分配⽅式的不同 | 堆上的内存是动态分配的，程序在运行时可以根据需要分配和释放内存 | 栈上的内存是自动分配和释放的，通常用于存储函数调用过程中的局部变量、返回地址和寄存器状态等信息。当函数被调用时，栈上的内存会自动分配；当函数返回时，栈上的内存会自动释放 |
| ⽣命周期的不同     | 堆上的内存⽣命周期取决于程序员⼿动分配和释放。分配的堆内存在程序运⾏过程中⼀直存在，直到被显式释放或程序结束 | 栈上的内存⽣命周期与函数调用相关。局部变量在函数被调用时自动分配内存，函数返回时自动释放内存 |
| 内存管理的不同     | 堆上的内存需要程序员⼿动管理。程序员负责在适当的时机分配和释放内存，以避免内存泄漏和资源浪费。手动管理堆内存可能导致错误，如内存泄漏、野指针、重复释放等 | 栈上的内存由操作系统和编译器自动管理，程序员无需关⼼内存分配和释放的细节。这使得栈上的内存更容易使用，但局部变量的⽣命周期受到函数调用的限制 |
| 内存大小的不同     | 堆的大小通常比栈⼤得多，因此可以用于存储较⼤的数据结构和对象。然而，分配和释放堆内存的操作相对较慢，可能导致程序性能下降 | 栈的大小相对较⼩，适用于存储较⼩的数据结构和对象。分配和释放栈内存的操作非常快速，但栈空间有限，可能导致栈溢出错误 |

### 栈何时会溢出？

a. 递归调用层次过深：如果一个程序中存在递归调用，而递归调用的层次过深，会导致栈空间不足，从而发生栈溢出

b. 局部变量占用过多空间：当一个函数中声明了过多的局部变量，或者某个局部变量占用的内存空间过大时，会导致栈空间快速耗尽，从而发生栈溢出

c. 大量函数调用嵌套：如果程序中存在大量的函数调用嵌套，而栈空间不足以容纳所有的函数调用信息，也会导致栈溢出

### malloc是如何分配内存的？

**`malloc()` 并不是系统调用，而是 C 库里的函数，用于动态分配内存**   (会预分配更大的**内存池**，空间换时间)

a. **`brk()`**系统调用从堆分配内存（< 128KB）

通过 `brk() `函数将「堆顶」指针向高地址移动，获得新的内存空间，`free`后不会归还给操作系统，还是先缓存到内存池

- 频繁使用会产生内存碎片   ---为什么不只用`brk()`
- 使用内存池的内存不会触发**系统调用与缺页中断**

b. **` mmap() `**系统调用在文件映射区域分配内存（>=128KB）

通过 `mmap()` 系统调用中「私有匿名映射」的方式，在文件映射区分配一块内存，也就是从文件映射区“偷”了一块内存，`free`后会归还给操作系统

- 每次分配都会触发**系统调用与缺页中断**，CPU消耗较大 ---为什么不只用`mmap()`

### malloc和new的区别？

**a. 性质不同**：new是⼀个c++中特有的**操作符**，⽽malloc是c语⾔中的**内存分配函数**。New只能在c++中 使⽤，但是malloc在c++和c中都可以使⽤。
**b. 内存分配⽅式不同**：malloc分配的内存是未初始化的，⽽new不仅分配了内存，还调⽤了对象的**构造函数**来初始化对象。
**c. 使用语法不同**：malloc使⽤时需要指定分配内存的⼤⼩，如`malloc(sizeof(int))`, 但new不⽤，使⽤更加简洁，如：`new int`
**d. 返回类型**：malloc返回`void*`类型指针，需要强制转换成其它指定类型，⽽new直接返回相应的数据类型的指针，无需类型转换。
**e. 错误处理**：内存分配失败后，malloc返回`null`, ⽽new会抛出`std::bad_malloc`异常。
**f.  配对操作**：malloc分配内存使用`free`释放，⽽new分配内存要使用`delete`释放。

**==混用问题==**：混用`new`/`delete`和`malloc`/`free`会导致**未定义行为**，因为它们分配和释放内存的方式不同。例如，使用`new`分配的内存，可能包含对象的额外信息，用于正确地调用构造函数和析构函数。如果使用`free`来释放这块内存，会跳过析构函数的调用，并且可能无法正确释放内存，导致内存泄漏或其他错误

### 缺页中断？

**定义**：当 CPU 访问的页面不在物理内存(RAM)时，便会产生一个**缺页中断**，请求操作系统将所缺页调入到物理内存。或者CPU试图执行的操作违反了内存保护规则是，也会触发缺页终端，如试图写入一个只读页或试图访问一个无权访问的页面。

**区别**：缺页中断在指令执行「期间」产生和处理中断信号，而一般中断在一条指令执行「完成」后检查和处理中断信号；

​			缺页中断返回到该指令的开始重新执行「该指令」，而一般中断返回回到该指令的「下一个指令」执行

### 页面置换算法？

**功能**：页面置换算法的功能是，**当出现缺页异常，需调入新页面而内存已满时，选择被置换的物理页面**，也就是说选择一个物理页面换出到磁盘，然后把需要访问的页面换入到物理页

| 算法                           | 特点                                                         |
| ------------------------------ | ------------------------------------------------------------ |
| a. 最佳页面置换算法            | 置换在「未来」**最长时间不访问**的页面，它的**优点**是理论上能够得到最好的性能，因为总是选择最不可能被使用的页面进行替换。**缺点**是在实践中无法实现，因为无法预知未来的访问模式。所以，最佳页面置换算法作用是为了**衡量你的算法的效率**，你的算法效率越接近该算法的效率，那么说明你的算法是高效的 |
| b. 先进先出置换算法(FIFO)      | 置换在内存**驻留时间**最长的页面，**优点**是实现简单，不需要记录页面的使⽤情况。**缺点**是可能会导致性能下降，因为最早进⼊内存的页⾯并不⼀定是最少使用的 |
| c. 最近最久未使用(LRU)置换算法 | 置换最长时间**没有被访问**的页面，**优点**是能够较好地处理局部性原理，即最近使用过的页面在未来很可能还会被使用。**缺点**是实现起来相对复杂，需要维护⼀个所有页面的使用记录列表。 |
| d. 时钟页面置换算法            | 使用⼀个环形链表和⼀个**访问位**来模拟LRU算法，表针指向的页面访问位是**0**， 就置换；是**1**就将访问位置**0**，去遍历下一个，直到找到访问位是**0**的可置换页面。**优点**是实现相对简单，同时能够得到接近LRU的性能。**缺点**是如果访问模式发⽣变化，可能会导致性能下降。 |
| e. 最不常用(LFU)置换算法       | 置换访问次数最少的页⾯，它的优点是对于长期稳定的访问模式，能够得到较好的性能。缺点是如果访问模式发⽣变化，可能会导致性能下降，因为使用频率⾼的页面可能在未来不再被访问 |



# 数据结构

## 红黑树

|          | 二叉搜索树(BST)                                              | 平衡二叉树（AVL）                                            | 红黑树 (Red-Black Tree)                                      |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 性质     | 左子树小于根节点，右子树大于根节点                           | BST的前提下，左右子树高度差至多为1                           | BST的前提下，红黑规则，根节点黑色，无连续红节点，黑高平衡    |
| 平衡性   | 不保证平衡，最坏情况下高度为`n`                              | 高度平衡，最坏情况下高度为`logn`                             | 弱平衡(保证最长路径最多是最短路径的**2倍**)，最坏情况下高度为`2*log(n+1)`， |
| 旋转     | 不旋转                                                       | 插入时最多2次，删除时``O(logn)``，因为需要维护从被删除节点到根节点这条路径上所有节点的平衡 | ==**插入时最多2次，删除时最多3次**==                         |
| 操作效率 | 查找、插入和删除操作的平均时间复杂度为`O(log n)`，最坏为`O(n)` | 查找、插入和删除均为``O(log n)``，查找操作效率通常更高       | 查找、插入和删除均为`O(log n)`，插入删除操作效率通常更高     |
| 适用场景 | 数据分布均匀或不需要频繁插入和删除操作的场景                 | 查找操作频繁且插入和删除操作较少的场景(或者数据分布好)，需要高查找效率的应用 | ==频繁插入和删除操作==的场景，如C++ STL的map和set、I/O多路复用的epoll |

红黑树是牺牲了严格的高度平衡的优越条件为代价，它只要求部分地达到平衡要求，降低了对旋转的要求，从而提高了性能。

红黑树的算法时间复杂度和AVL（平衡二叉树）相同，但统计性能比AVL树更高，所以在插入和删除中所做的后期维护操作AVL肯定会比红黑树要耗时多

**性质**:

a. 每个节点要么是红色，要么是黑色

b. 根节点总是黑色的

c. 所有的叶⼦节点（NULL节点）都是黑色的

d. 如果⼀个节点是红⾊的，那么它的两个⼦节点必须是黑色的（即不允许有连续的红色节点）

e. 从任意节点到其每个叶⼦节点的所有路径上，黑色节点的数量相同（称为黑高平衡）

## STL容器概述

### 1. vector

- **底层结构**：由 动态数组 实现 , 特点是 存储空间 连续
- **访问遍历**: 支持 随机访问迭代器 , 可使用下标访问 , 访问元素非常快 O(1) 复杂度
- **插入 / 删除** : 尾部插入 / 删除效率高 O(1)； 中间 和 头部插入/删除效率低 , 由于存储空间连续 , 需要将插入 / 删除位置之后的元素依次改变位置 , O(n)  
- **空间效率** : 底层实现时 , 会事先预留一些额外空间 , 以减少重新分配的次数 
- **使用场景** : 需要 随机访问且频繁在尾部进行操作 的场景 ; 如果频繁增删元素 则 不适用该容器 

### 2. list

- **底层结构** : 底层由 双向链表 实现 , 特点是 存储空间 不连续 
- **访问遍历** : 不支持 随机访问迭代器 , 只能通过迭代器进行访问 
- **插入 / 删除** : 任意位置 插入 / 删除 效率都很高 
- **空间效率** : 每个元素 都需要 分配额外的空间 , 存储 当前元素的 前驱元素 和 后继元素 
- **使用场景** : 需要 在任意位置 频繁 插入 / 删除 操作的 场景 

### 3. deque

+ **底层结构**: 底层由 双向队列 实现 , 特点是 存储空间 连续 
+ **访问遍历**: 支持 随机访问迭代器 , 其性能比 vector 动态素组要低 
+ **插入 / 删除** : 头部 和 尾部 插入 / 删除效率高 , O(1) ; 中间 插入/删除效率低 , 由于存储空间连续 , 需要将插入 / 删除位置之后的元素依次改变位置 , 比 vector 动态数组要快一些 
+ **空间效率** : 底层实现时比 vector 的结构要复杂 , 也会事先预留一些额外空间 , 以减少重新分配的次数 
+ **使用场景** : 需要 随机访问 且 频繁在 首部 和 尾部 进行操作 的场景 ; 如果频繁 在中部 增删元素 则 不适用该容器

### 4. set

- **底层结构**: 底层由 红黑树 实现 , 红黑树 是 一种 平衡二叉搜索树 , 存储空间 不连续
- **访问遍历** : 不支持 随机访问迭代器 , 不能通过下标访问 , 只能通过迭代器进行访问 ;
- **插入 / 删除** : 查询 / 插入 / 删除 效率 为 O(log n) 
- **排序方式** : 默认使用 less 仿函数 , 即 < 运算符(升序)进行排序 ; 也可以自定义 排序规则 仿函数 
- **使用场景** : 需要 有序集合 且 元素 不重复 的场景 (multiset 支持重复的元素)

### 5. map

- **底层结构** : 底层由 红黑树 实现 , 红黑树 是 一种 平衡二叉搜索树 , 存储空间 不连续 ; 存储的 元素 是 键值对 元素 
- **访问遍历** : 不支持 随机访问迭代器 , 不能通过下标访问 , 只能通过迭代器进行访问 
- **插入 / 删除** : 查询 / 插入 / 删除 效率 为 O(log n) 复杂度 ; 与 set 集合容器相同 
- **排序方式** : 默认使用 less 仿函数 , 即 < 运算符进行排序 ; 也可以自定义 排序规则 仿函数 ; map 映射容器 不允许重复的键 , multimap 多重映射容器允许重复的键 
- **使用场景** : 需要 有序 键值对 且 元素 不重复 的场景
- std::map 映射容器 与 std::set 集合容器 的**区别**是 map 容器存储的是 键值对 元素 , 是 pair 对象 , set 容器 存储的是 单纯的 键 单个元素 

### ![image-20240611144607976](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406121745039.png) 

## STL容器详解

### 1. vector

>  **“长度根据需要而自动改变的数组”**

- 定义：`vector<typename> name; vector<vector<int>> name2;`
- 容器内的访问：
  - 通过下标
  - 通过迭代器访问：`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- vector常用函数：
  - **push_back()**：在vector后面添加一个元素x，时间复杂度为o(1)。
  - **pop_back()**：删除vector的尾元素，时间复杂度为o(1)。
  - **size()**：获得vector中元素的个数，时间复杂度为o(1)。
  - **clear()**：用来清空vector中的所有元素，时间复杂度为o(N)。
  - **insert()**：insert(it, x)用来向vector的任意迭代器it（这是一个指针变量）处插入一个元素x，时间复杂度为o(N)。
  - **erase()**：它有两种用法：
    - 删除单个元素，erase(it)即删除迭代器为it处的元素；
    - 删除一段区间内的所有元素，erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
- vector常见用途：
  - 储存数据：在一些元素不确定的情况下可以很好节省空间，还有在一些场合需要根据条件把部分数据输出在同一行，最后不要空格，可以用vector数组先记录，然后一次性输出。
  - 用邻接表存储图

### 2. set

> **”内部自动有序且不含重复元素的容器“**

- 定义：`set<typename> name;`   如果typename是一个容器，注意在定义时记得在>>符号之间加上空格，有些编译器会把它视为移位操作。
- set容器内元素的访问：只能通过迭代器`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- set常用函数：
  - **insert()**：insert(x)可将x插入set容器中，自动实现排序和去重，o(logN)。
  - **find()**：find(value)，返回set中对应值为value的容器，o(logN)。
  - **erase()**：它有两种用法：
    - 删除单个元素，st.erase(it)即删除迭代器为it处的元素，*st.erase(value)，value为要删除的元素*；
    - 删除一段区间内的所有元素，erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
  - **size()**：获得vector中元素的个数，时间复杂度为o(1)。
  - **clear()**：用来清空set中的所有元素，时间复杂度为o(N)。
- set的常见用途：最主要的作用就是自动去重并按升序排序。

### 3. string

> **“对字符串常用需求进行了封装”**

- 定义：`string str; string str1 = "abcdef";` 要读入输出string类，只能使用cin，cout。
- 容器内的访问：
  - 通过下标
  - 通过迭代器访问：`for(auto it = v.begin(); it != v.end(); it++ ) printf("%d", *it);`
- string常用函数：
  - **operator +=**：可以直接用+号把两个string拼接起来。
  - **compare operator**：两个string类型可以直接使用==、!=、<、等比较大小，比较规则是字典序。
  - **length()/size()**：返回长度。
  - **insert()**：string的insert函数有很多写法
    - **insert(pos, string)**：在pos号位置插入字符串string。
    - **insert(it, it2, it3)**：it为原字符串的欲插入迭代器位置，it2和it3为待插入字符串的首尾迭代器，用来表示串[it2, it3)将被插入在it的位置上。
  - **erase()**：它有两种用法：
    - 删除单个元素，str.erase(it)即删除迭代器为it处的元素；
    - 删除一段区间内的所有元素，str.erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。**str.erase(pos, length)，在起始位置pos删除length个字符**。
  - **clear()**：用来清空string中的所有元素，时间复杂度为o(N)。
  - **substr()**：`str.substr(pos, len)`返回从pos号位开始，长度为len的子串。
  - **find()**：
    - `str.find(str2)`，当str2是str的子串时，返回其在str中第一次出现的位置；如果不是，返回string::npos。
    - `str.find(str2, pos)`，从str的pos位开始匹配str2，返回值同上。o(nm)。
  - **replace()**：
    - `str.replace(pos, len, str2)`把str从pos位开始、长度为len的子串替换为str2。
    - `str.replace(it1, it2, str2)`把str迭代器[it1, it2)的子串替换为str2。

### 4. map

> **“可以将任何基本类型映射到任何基本类型”**

- 定义：`map<typename1, typename2> mp;`
- 容器内的访问：
  - 通过下标`map[typename1] == typename2`
  - 通过迭代器访问:it->first 键，it->second 值
- map常用函数：
  - **find()**：`find(key)`返回键为key的映射的*迭代器*。
  - **erase()**：它有两种用法：
    - `mp.erase(it)`即删除迭代器为it处的元素。
    - `mp.erase(key)`，key为欲删除的映射的键。
    - 删除一段区间内的所有元素，mp.erase(first, last)即删除[first, last)的所有元素，参数也是指针变量。
  - **size()**：用来获得map中映射的对数。
  - **clear()**：用来清空map中的所有元素，时间复杂度为o(N)。
- map的常见用途：
  - 需要建立字符（或字符串）与整数之间的映射，可以用map减少代码量。
  - 判断大整数或者其他类型数据是否存在，可以把map当bool用。
  - 字符串与字符串的映射。

### 5. queue

> **“有队列的常用操作封装”**

- 定义：`queue<typename> name;`
- 容器内的访问：只能通过front()，back()访问队首，队尾元素。
- queue常用函数：
  - **push()**：入队。
  - **pop()**：出队。
  - **empty()**：检测queue是否为空，返回true则空，false则非空。
  - **size()**：返回queue内元素的个数。
- queue的常见用途：广度优先搜索。

### 6. stack

> **“有栈的常用操作封装”**

- 定义：`stack<typename> name;`
- 容器内的访问：只能通过top()访问栈顶元素。
- stack常见函数：
  - **push()**：入栈。
  - **top()**：取栈顶。
  - **pop()**：出栈，弹出栈顶元素。
  - **empty()**：检测stack是否为空，返回true则空，false则非空。
  - **size()**：返回stack内元素的个数。
- stack的常见用途：模拟实现一些递归，例如DFS。

### 7. algorithm头文件下的常用函数

- **max()、min()、abs()**：前两个函数参数是两个。
- **swap()**：交换两个数的值。
- **reverse()**：reverse(it, it2)可以将数组指针在[it, it2)之间的元素或容器的迭代器在[it, it2)范围内的元素进行反转。
- **fill()**：和memset不同，这里的赋值可以是数组类型对应范围中的任意值。
- **sort()**：sort(首元素地址，尾地址的下一个元素，比较函数)。对于结构体的排序要记住。
- **lower_bound()和upper_bound()**：需要用在一个有序数组或容器中。
  - `lower_bound(first, last, val)`用来寻找数组或容器的[first, last)范围内**第一个值大于等于val的元素的值**，如果是数组，则返回该位置的指针，若是容器，则返回该位置的迭代器。
  - `upper_bound(first, last, val)`用来寻找数组或容器的[first, last)范围内**第一个值大于val的元素的值**，如果是数组，则返回该位置的指针，若是容器，则返回该位置的迭代器。

## TODO: 各种排序

# 数据库

## MySQL

![image-20240622142939108](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406221429267.png) 



# Docker

## 基本概念

### 常用命令

https://www.yuque.com/leifengyang/sutong/au0lv3sv3eldsmn8

### 定义

==**什么是Docker**==:  开源的容器化平台，用于快速**构建、分享、运行**应用程序

### 架构

**Docker**的架构：

![image-20240623205341901](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240233.png)

### 镜像与容器

- **镜像**：==可以理解为软件包==，是一个只读模板，包含了运行应用程序所需的所有内容，包括代码、库、环境变量和配置文件。**镜像是创建容器的基础**
- **容器**：==可以理解为用软件包启动起来的一个应用，每一个运行中的应用称之为一个容器==，**容器是镜像的一个实例**，它运行一个独立的进程，具有自己的文件系统、网络接口和资源限制。容器与虚拟机不同，容器共享宿主操作系统的内核，但仍然提供隔离环境
- **容器与虚拟机的区别**：

1. 传统化部署：一个应用产生内存泄漏，就会挤压其他应用的生存空间，导致所有应用不能正常运行，即**应用之间不隔离**
2. 虚拟化部署：不同虚拟机之间的应用不会相互干扰，即**应用之间相互隔离**，每个虚拟机都是独立的操作系统，拥有自己的系统内核，故**比较笨重**
3. 容器化部署：即拥有**隔离特性**，但每个容器都**共享宿主操作系统的内核**，不需要为每个容器安装完整的操作系统，故**更加轻量**，容器拥有自己的文件系统、CPU、内存、进程空间等

 ![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240234.png) 

## 实验

启动一个 nginx ,并将它的首页改为自己的页面，发布出去，让所有人都能使用

![image-20240623214639440](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240235.png)

### 下载镜像

- **搜索镜像**： `docker search xxx`

![image-20240623220023494](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240236.png) 

- **拉取镜像**：`docker pull xxx`

![image-20240623220243597](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406232240237.png) 

### 启动容器

- **用镜像来启动一个容器**：`docker run xxx:xxx`

![image-20240624154300882](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924795.png)  

![image-20240624154539923](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924796.png)  

### docker run 详解

- **后台启动容器、给容器取名**：`docker run -d --name mynginx nginx` 

![image-20240624155222380](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924797.png)  

- **端口映射**：将主机端口映射到容器端口`docker run -p 80:80 nginx`，这样就访问主机的80端口就是访问容器的80端口
  **主机端口 80 映射到一个容器端口后，就不能用于映射另外一个容器的端口了**

![image-20240624155607994](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924798.png) 

![image-20240624155914073](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924799.png)  

### 进入容器并修改

-  `docker exec -it xxx /bin/bash` 
  在ID为 `829` 的容器中启动一个交互式的 Bash shell 会话，并将当前的终端连接到该会话上。这允许你在容器内部运行命令，就像在普通的 Linux 终端中一样

![image-20240624161122961](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924800.png) 

![image-20240624161159466](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924801.png)  

### 保存镜像

- **创建新镜像**：`docker commit -m "update index.html" 829 mynginx:v1.0`
  在 ID 为 `829` 的容器的当前状态下创建一个新的 Docker 镜像，镜像的名称为 `mynginx`，标签为 `v1.0`。并且，给这个新镜像添加了一条注释信息 “update index.html”

![image-20240624161727938](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241617998.png) 

- **保存镜像为文件**：`docker save -o myngnix.tar mynginx:v1.0`
  将名为`mynginx`、标签为`v1.0`的Docker镜像导出并保存到当前目录下的`myngnix.tar`文件中

![image-20240624162053159](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924802.png) 

-  **根据文件加载镜像**：`docker load -i mynginx.tar`

![image-20240624163247636](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924803.png) 

![image-20240624163335152](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924804.png) 

 

 ### 分享镜像到社区

- **登录**：`docker login`

![image-20240624164229333](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924805.png) 

- **命名**：`docker tag xxx xxx`

![image-20240624164506732](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924806.png)  

- **推送**：`docker push xxx`

![image-20240624164924698](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406241924807.png) 

##  Docker 存储

---==**让数据不再丢失**==

**容器内部数据管理存在的问题**：

1. **修改麻烦**：容器里面的文件数据需要**进入容器**修改

2. **容易丢失**：若修改后如果不保存其镜像，**容器挂了之后就没了**

### 目录挂载

docker 允许用户在自己的机器上**专门创建一个目录用以挂载容器内部的某个目录**，这样**在容器外部修改数据对内部也是有效的，同时内部修改对外部也是可见的**

命令：启动容器时，`-v 外部路径:容器内部路径` =

![image-20240625134011556](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737830.png) 

![image-20240625134046540](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737831.png) 

![image-20240625134126731](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251341805.png)   

这样，无需进入容器也可修改数据，同时若容器删除，下次启动时只需用同样的命令将外部目录挂载上去就行，不会丢失修改

但是，初始化时，如果外部目录没有数据，挂载上去相当于容器内部也没有数据了，即第一次要在外部目录再创建

### 卷映射

初始化时，外部目录的数据会与容器内部保持一致

命令：启动容器时，`-v 卷名:容器内部路径`  其中外部卷，docker 统一放在 `/val/lib/docker/volumes/`下

![image-20240625140218420](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737832.png) 

![image-20240625140306726](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737833.png) 

## Docker 网络

--- ==**轻松构建集群**==

**容器访问容器**

### 方法1

**方法1：容器1 -> 访问主机 -> 访问容器2**

![image-20240625155621302](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737834.png)  

### 方法2

**方法2：容器1 -> 容器2(同一主机下)**

安装docker后可以通过 `ip a` 查看 docker 创建的网络(docker0)，此后 docker 每启动的一个应用(容器)都会加入这个网络，且每一个应用 docker 都会为其分配 IP

 ![image-20240625160049245](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737835.png) 

用`docker container inspect app1`查看 app1 这个容器的细节

![image-20240625160434228](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737836.png) 

故同一主机下的容器之间，可以直接用 docker 分配的 IP 通信

 ![image-20240625160847374](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737837.png) 

![image-20240625160709104](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737838.png) 

问题：IP 不固定，可能由于各种原因变化，如重启、删除...，故需要一个更稳定的访问方式--->域名

### 方法3

**方法3：自定义网络，容器加入后容器名作为这个容器的域名，之后容器间通过域名访问**

![image-20240625161331715](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737839.png)  

创建自定义网络：

![image-20240625161805981](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737840.png) 

创建容器时将其加入自定义网络，之后便可通过域名通信：

![image-20240625162159580](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737841.png)  

## 实验：Redis 主从同步集群

### 实验目的

启动两个 Redis 容器，redis01 作为主机，redis02作为从机，**从机同步主机，主机发生了变化从机需要与其保持一致**

以此实现==**读写分离**==：所有的写请求(增加、删除、修改)交给主机，所有的读请求(查询)交给从机

这样用两个 Redis 实例来分担读写请求，就要比用一个实例来处理更稳定且鲁棒

**注**：这是个模拟实验，实际生产环境中主从是两台机器，即不同主机间的容器，所以通信应该使用上文**Docker网络**的**方法1**

![image-20240625162941332](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737842.png) 

### 实验流程

1. 将两个 Redis 容器放到同一个自定义网络中
2. 容器1开放 6379 端口并映射到主机的 6379 端口，容器 2 开放 6379 端口并映射到主机的 6380 端口
3. 为了数据安全，将 Redis 容器中的数据挂载到主机
4. 设置参数让容器 2 同步容器 1 的数据(主从同步)：
   -> 设置主机的复制模式为 master 同时给其一个访问密码
   -> 设置从机的复制模式为 slave，告诉从机主机的域名、端口和密码，给从机一个访问密码

![image-20240625164814040](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737843.png) 

```shell
sudo docker run -d -p 6379:6379 \
-v /app/rd1:/bitnami/redis/data \
-e REDIS_REPLICATION_MODE=master \
-e REDIS_PASSWORD=123456 \
--network mynet --name redis01 \
bitnami/redis

sudo docker run -d -p 6380:6379 \
-v /app/rd2:/bitnami/redis/data \
-e REDIS_REPLICATION_MODE=slave \
-e REDIS_MASTER_HOST=redis01 \
-e REDIS_MASTER_PORT_NUMBER=6379 \
-e REDIS_MASTER_PASSWORD=123456 \
-e REDIS_PASSWORD=123456 \
--network mynet --name redis02 \
bitnami/redis
```

**启动主机**：![ ](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737844.png)

**启动从机**： 

![image-20240625171129739](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737845.png)  

### 实验结果

主机增加 k-v：

![image-20240625173342450](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737846.png) 

从机同步 k-v：

 ![](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406251737847.png)

## Docker Compose

--- ==**批量管理容器**==

### 如何使用

1. 准备一个 `.yaml` 文件
2. 将所有要启动的所有容器的配置都写到 `.yaml` 文件中
3. 使用 `docker compose` 命令批量启动、停止、删除 `.yaml` 中的容器

![image-20240626123522374](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703641.png) 

### 实验

启动一个博客应用及其需要的数据库

- 命令式安装：

```shell
#创建自定义网络
docker network create blog

#启动mysql
docker run -d -p 3306:3306 \
-e MYSQL_ROOT_PASSWORD=123456 \
-e MYSQL_DATABASE=wordpress \
-v mysql-data:/var/lib/mysql \
-v /app/myconf:/etc/mysql/conf.d \
--restart always --name mysql \
--network blog \
mysql:8.0

#启动wordpress
docker run -d -p 8080:80 \
-e WORDPRESS_DB_HOST=mysql \
-e WORDPRESS_DB_USER=root \
-e WORDPRESS_DB_PASSWORD=123456 \
-e WORDPRESS_DB_NAME=wordpress \
-v wordpress:/var/www/html \
--restart always --name wordpress-app \
--network blog \
wordpress:latest
```

- `.yaml` 式安装：

```yaml
name: myblog # 本次部署的服务名称
services:    # 服务中要启动的所有应用
  mysql:
    container_name: mysql # 容器名
    image: mysql:8.0	  # 启动的镜像
    ports:				  # 端口映射
      - "3306:3306"
    environment:		  # 环境变量
      - MYSQL_ROOT_PASSWORD=123456
      - MYSQL_DATABASE=wordpress
    volumes:			   
      - mysql-data:/var/lib/mysql       # 卷映射	 
      - /app/myconf:/etc/mysql/conf.d   # 目录挂载
    restart: always		  # 开机自启
    networks:			  # 加入的网络
      - blog

  wordpress:
    image: wordpress
    ports:
      - "8080:80"
    environment: 		 # 环境变量，k-v 写法
      WORDPRESS_DB_HOST: mysql
      WORDPRESS_DB_USER: root
      WORDPRESS_DB_PASSWORD: 123456
      WORDPRESS_DB_NAME: wordpress
    volumes:
      - wordpress:/var/www/html
    restart: always
    networks:
      - blog
    depends_on:  # 需要让数据库先启动
      - mysql

volumes:      # 在顶级元素`volumes`中声明映射的卷名
  mysql-data:
  wordpress:

networks:     # 在顶级元素`network`中声明用到的网络
  blog:
```

![image-20240626131303715](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703642.png) 

## Dockerfile

---==**构建自定义镜像**==

### 制作镜像

用 `Dockerfile` 编写制作镜像的指令，Docker 的构建器(`Builder`) 就会根据其构建镜像，镜像中要包含：软件运行的基础环境、软件包和启动命令

![image-20240626134120328](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703643.png) 

```shell
FROM openjdk:17

LABEL author=leifengyang

COPY app.jar /app.jar

EXPOSE 8080

ENTRYPOINT ["java","-jar","/app.jar"]
```

### 镜像分层存储机制

- Docker 镜像采取**增量存储**

![image-20240626161412516](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703644.png) 

- 容器与镜像存储机制

![image-20240626161811760](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703645.png) 

![image-20240626165119610](https://496051480-1319142273.cos.ap-guangzhou.myqcloud.com/202406261703646.png) 

# TOOLs

## tcpdump

```shell
// 基于 IP 过滤
sudo tcpdump host 192.168.10.0 	  // 抓主机 192.168.10.0 收到和发出的所有包
sudo tcpdump dst/src 192.168.10.0 // 抓目的地/发送源是 192.168.10.0 的包
sudo tcpdump net 192.168.10.0/24  // 抓子网是 192.168.10.0/24 的包 即 192.168.10.0~255 (24表示前24位子网，剩下8位是主机)

// 基于 PORT 过滤
sudo tcpdump port 80 // 抓 80 端口的包
sudo tcpdump port 80 or 22 // 抓 80 和 22 端口的包
sudo tcpdump portrange 8000-8080 // 抓 8000-8080 的包
sudo tcpdump port http // 常见协议的默认端口可以直接使用协议名抓包 http==80 https==443

// 基于协议过滤
sudo tcpdump icmp // 抓指定协议的包 一般常用：ip、ip6、arp、icmp、tcp、udp 等
sudo tcpdump port http // 应用层协议 http、dns、https、ssh 等，不能直接按上面那样按协议过滤，需要通过端口过滤

// 常用参数
sudo tcpdump -h // 查看所有参数
sudo tcpdump -i eth0/any // 抓指定网卡的包 eth0/所有网卡
sudo tcpdump -i eth0 -w test.pcap // 抓eth0网卡的包并保存成 test.pcap 文件  ifconfig 可查看网卡信息
sudo tcpdump -r test.pacp // 从 test.pcap 文件读取数据

sudo tcpdump -n // 不将ip转为域名，直接显示ip，避免执行DNS lookups 的过程，速度会快很多
sudo tcpdump -nn // 不把协议和端口转为名字，速度也会快很多
sudo tcpdump -t // 在每行的输出中不输出时间
sudo tcpdump -tt // 在每行的输出中打印时间戳(自1970年1月1日以来的时间（通常称为UNIX时间戳），单位为秒和微秒)
sudo tcpdump -ttt // 输出每两行打印的时间间隔(以毫秒为单位)
sudo tcpdump -tttt // 在每行答应的时间戳之前添加日期的打印

sudo tcpdump -v // 产生详细的输出，如包的TTL，id标识，数据包长度 -vv 更详细  -vvv更更详细
sudo tcpdump -c // 指定抓包次数，收到指定数量的包后退出tcpdump 停止抓包
sudo tcpdump -C // 与-w配合使用，比如 tcpdump -C 1 -W 3 -w abc 指定抓满1MB就换文件，最多写3个文件，名字是abc0 abc1 abc2
sudo tcpdump -q // 简洁地打印输出 只显示基本的摘要信息，减少冗长的详细信息
sudo tcpdump -Q // 指定抓包方向 tcpdump -Q in/out/inout 进入/离开/所有方向
sudo tcpdump -D // 列出系统中所有可用的网络接口

sudo tcpdump -s // 指定每个数据包的捕获长度(单位：字节) 即只捕获每个包的前n个字节
sudo tcpdump -A // 将捕获的数据包内容以 ASCII 格式打印出来。这个选项特别有用，可以查看数据包中的文本数据，例如 HTTP 请求和响应内容、明文协议的数据
sudo tcpdump -X // 以十六进制和 ASCII 格式显示捕获的数据包内容。这个选项特别有用，可以查看数据包的详细内容，包括非文本数据
sudo tcpdump -e // 显示源和目的MAC地址

sudo tcpdump -F // 从指定的文件读取过滤表达式，而不是直接在命令行中输入过滤表达式,方便过滤表达式管理和重用

// 过滤规则逻辑运算
sudo tcpdump src 100.100.30.26 and port 80 // 抓来自100.100.30.26主机且端口是80的包
sudo tcpdump tcp port 53 or udp port 53 // 抓UDP 53端口或者TCP 53端口的包(DNS协议的报文)
sudo tcpdump not tcp port 22 // 抓不是22端口的报文 not == ！
sudo tcpdump "src 10.0.2.4 and (dst port 3389 or 22)" // 抓源 IP 地址为 10.0.2.4，并且目标端口为 3389 或 22 的数

// 基于大小过滤
sudo tcpdump less 32 // 抓包小于 32 个字节的包
sudo tcpdump greater 300 // 抓包大于 32 个字节的包
```

## CMAKE

- `# `注释一行  `#[[]]` 注释多行

```cmake
# 这是一个 CMakeLists.txt 文件
cmake_minimum_required(VERSION 3.0.0)

#[[ 这是一个 CMakeLists.txt 文件。
这是一个 CMakeLists.txt 文件
这是一个 CMakeLists.txt 文件]]
cmake_minimum_required(VERSION 3.0.0)
```

- `CMakeLists.txt` ：`touch CMakeLists.txt` 创建一个 CMakeLists.txt

```cmake
# 指定使用的 cmake 的最低版本 可选 不加可能警告
cmake_minimum_required(VERSION 3.0) 
# 定义工程名称，并可指定工程的版本、工程描述、web主页地址、支持的语言
project(CALC) 
# 定义工程会生成一个可执行程序，第一个是生成的可执行文件名，后面是源文件名称
add_executable(app add.c div.c main.c mult.c sub.c) # 源文件名可以是一个也可以是多个，如有多个可用空格或;间隔
add_executable(app add.c;div.c;main.c;mult.c;sub.c) 
```

- 生成`makefile`

```shell
cmake ./CMakeLists.txt # CMakeLists.txt路径
make # 再执行make命令，就可以对项目进行构建得到所需的可执行程序了
```

- 创建build文件夹，将 cmake 过程中于源码无关的文件统一放置

```shell
mkdir build
cd build
cmake .. // 在build目录中会生成一个makefile文件
make // 完成编译，将cmake和make生成的所有文件和项目源文件隔离
```

- 定义变量：假设源文件需要重复使用，可定义变量将文件名对应的字符串存储

```cmake
# SET 指令的语法是：
# [] 中的参数为可选项, 如不需要可以不写
SET(VAR [VALUE] [CACHE TYPE DOCSTRING [FORCE]]) # VAL 变量名 VALUE 变量值
```

- 指定使用的 C++ 标准

```cmake
# 方法1：在 CMakeLists.txt 中通过 set 命令指定
#增加-std=c++11
set(CMAKE_CXX_STANDARD 11)
#增加-std=c++14
set(CMAKE_CXX_STANDARD 14)
#增加-std=c++17
set(CMAKE_CXX_STANDARD 17)

# 方法2：在执行 cmake 命令的时候指定出这个宏的值
#增加-std=c++11
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=11
#增加-std=c++14
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=14
#增加-std=c++17
cmake CMakeLists.txt文件路径 -DCMAKE_CXX_STANDARD=17

# CMAKE_CURRENT_SOURCE_DIR 宏表示当前访问的 CMakeLists.txt 文件所在的路径。
# PROJECT_SOURCE_DIR 宏表示当前的根目录
```

- 指定输出的路径

```cmake
set(HOME /home/robin/Linux/Sort) # 定义一个变量用于存储一个绝对路径 如果路径不存在会创建
set(EXECUTABLE_OUTPUT_PATH ${HOME}/bin) # 将拼接好的路径值设置给EXECUTABLE_OUTPUT_PATH宏
```

- 搜索文件

```cmake
# 方法1：  aux_source_directory(< dir > < variable >) # dir:要搜索的目录 variable:将从 dir 目录下搜索到的源文件列表存储到该变量中
aux_source_directory(${CMAKE_CURRENT_SOURCE_DIR}/src SRC_LIST)


# 方法2： file(GLOB/GLOB_RECURSE 变量名 要搜索的文件路径和文件类型) 
#        GLOB 将指定目录下搜索到的满足条件的所有文件名生成一个列表，并将其存储到变量中
# 		 GLOB_RECURSE 递归搜索指定目录，将搜索到的满足条件的文件名生成一个列表，并将其存储到变量中
file(GLOB MAIN_SRC ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp)
file(GLOB MAIN_HEAD ${CMAKE_CURRENT_SOURCE_DIR}/include/*.h)
```

- 包含头文件：将源文件对应的头文件路径指定出来，这样才能保证在编译过程中编译器能够找到这些头文件

```cmake
include_directories(headpath) # headpath即头文件存放路径

cmake_minimum_required(VERSION 3.0) # 版本
project(CALC) 						# 项目名
set(CMAKE_CXX_STANDARD 11)          # C++ 标准
set(EXECUTABLE_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/bin/) # 输出路径
include_directories(${PROJECT_SOURCE_DIR}/include) # 指定头文件路径
file(GLOB SRC_LIST ${CMAKE_CURRENT_SOURCE_DIR}/src/*.cpp) # 搜索 /src 下所有 .cpp 
add_executable(app  ${SRC_LIST}) # 生成可执行文件
```

- 制作静态库：在Linux中，静态库名字分为三部分：**lib+库名字+.a**，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充

```cmake
add_library(库名称 STATIC 源文件1 [源文件2] ...) 
```

- 制作动态库：在Linux中，动态库名字分为三部分：**lib+库名字+.so**，此处只需要指定出库的名字就可以了，另外两部分在生成该文件的时候会自动填充

```cmake
add_library(库名称 SHARED 源文件1 [源文件2] ...) 
```

- 指定静态库、动态库生成输出路径

```cmake
# 设置动态库/静态库生成路径
set(LIBRARY_OUTPUT_PATH ${PROJECT_SOURCE_DIR}/lib)
# 生成动态库
#add_library(calc SHARED ${SRC_LIST})
# 生成静态库
add_library(calc STATIC ${SRC_LIST})
```

- 链接静态库

```cmake
link_directories(<lib path>)
# 如果该静态库不是系统提供的（自己制作或者使用第三方提供的静态库）可能出现静态库找不到的情况，此时可以将静态库的路径也指定出来
link_libraries(<static lib> [<static lib>...]) 
# para1:要链接的静态库的名,可以是全名也可以是库名 para2:要链接的其它静态库的名字
```

- 链接动态库

```cmake
link_directories(<lib path>)
# 如果该动态库不是系统提供的（自己制作或者使用第三方提供的动态库）可能出现动态库找不到的情况，此时可以将动态库的路径也指定出来
target_link_libraries(
    <target> 
    <PRIVATE|PUBLIC|INTERFACE> <item>... 
    [<PRIVATE|PUBLIC|INTERFACE> <item>...]...)
# para1：指定要加载动态库的文件的名字 para2:动态库的访问权限，默认为PUBLIC

# 在cmake中指定要链接的动态库的时候，应该将命令写到生成了可执行文件之后
# 静态库：链接阶段被复制到可执行文件中(.text .data .bss...),所以可执行程序一启动，静态库就被加载到内存中了
# 动态库：链接阶段只复制 重定位和符号表信息 可执行程序被启动并且调用了动态库中的函数的时候，动态库才会被加载到内存
```



## GIT

```shell
# 添加代码并提交
git add .
git commit -m 'update'
git push -u origin v1:main
```

## SHELL

### 1. bash VS sh

`bash` 和 `sh` 都是 Unix 和 Linux 系统中的命令行解释器（Shell），但它们之间有一些重要的区别

`bash` 提供了比 `sh` 更强大的功能，包括：

- 命令行编辑
- 历史记录
- 命令别名
- 更多的控制结构（例如 `[[ ]]` 测试命令）
- 高级的脚本编写功能
- `bash` 提供了更丰富的内置命令和功能，使得编写和调试脚本更加方便。

### 2

## protobuf

https://subingwen.cn/cpp/protobuf/



# CV

- 熟练使用C/C++，熟悉面向对象编程，掌握C++11新特性(智能指针等)及内存管理，理解泛型编程及RAII思想
- 熟悉数组、链表、栈、二叉树、哈希表等常用数据结构，熟悉查找、排序、DFS、DP等算法
- 熟悉Linux下socket网络编程，掌握Linux下I/O多路复用技术，对epoll模型有较深理解，了解Reactor模式
- 熟悉Linux下多进程、多线程编程，熟悉并发编程下进程间通信以及线程间同步互斥机制，理解线程安全
- 熟悉TCP/IP网络模型，熟悉常见的网络协议，如HTTP、HTTPS、TCP、IP等，会使用tcpdump + wireshark进行基础的抓包分析
- 了解CMAKE、GDB、Git等常用开发工具，能够完成简单的项目构建、调试和版本控制

项目1：Linux 下高并发 HTTP 服务器

项目描述：在Linux系统下开发的HTTP服务器，基于多进程实现了用户接入、业务处理、日志读写与数据库增删改查等功能

- 基于多态、C++11新特性与泛型编程思想封装了可调用对象类模版，用于承接不同类型的函数指针和函数参数以生成对应的可调用对象，实现各进程对象与线程对象可接入任意函数作为任务函数
- 封装套接字类，将C/S通信流程抽象为五个对外接口，支持本地/网络、UDP/TCP、监听/连接等套接字的创建，屏蔽了不同类型套接字的区别
- 封装线程池类，对外提供开启、任务添加和关闭接口，对内基于本地套接字和 epoll 来分发任务，无需引入加锁的任务队列，规避了线程池中多线程竞争任务带来的同步互斥问题
- 用户接入模块基于 Reactor 网络模式，利用 epoll 的高效事件通知机制和线程池的并发处理能力，只负责处理网络用户的接入请求，随后将连接全分发给业务处理模块做后续处理
- 针对实际应用中业务需求易变更、内容繁杂等特点，通过接口类来解耦用户接入与业务处理，业务处理模块通过继承业务接口类来完成具体的业务处理
- 设计了分级日志模块，支持流式日志，使用线程局部存储来提高各模块并发写日志的安全性与效率
- 封装 MySQL 数据库表类与列类，实现对象关系映射，同时利用 MD5 加密来提高用户登录的安全性

项目2：远程桌面控制系统

项目描述：在Windows系统下开发的远程桌面控制系统，完成了控制端(客户端)对被控端(服务端)的鼠标操作、文件操作、屏幕监控、锁机等功能

- 完成传输数据的协议封装与解析，通过对传输数据增加包头以及校验和来提高数据传输的可靠性和安全性
- 基于单例模式设计网络通信模块，同时考虑到单例模式的内存泄漏与线程安全问题并通过内部垃圾回收类与互斥锁加以优化
- 对服务端进行两次代码重构：通过增加中间层解耦了网络通信与业务处理模块，通过异步 I/O 模型 IOCP 提高了服务端的通信效率，基于UDP穿透实现跨局域网信息传输
- 客户端基于 MVC 设计模式实现了窗口与窗口、窗口与通信之间的解耦，通过 Windows 消息循环机制避免了多线程调用网络通信模块收发数据时的冲突

项目3：基于深度学习的视频目标分割方法

项目描述：在 Linux 系统下基于 pytorch 开发的半监督视频目标分割方法，提高了传统视频目标分割模型在相似目标干扰下的鲁棒性

- 设计全局-局部双分支结构用以进行特征增强，全局分支基于 Transformer，局部分支基于 CNN
- 优化了传统方法使用局部特征进行非局部匹配带来的相似目标错误分割的问题

自我评价：

热爱编程，热衷学习新技术，具备强执行力和责任感。积极主动，追求上进，抗压能力强
相关证书：

第十五届蓝桥杯湖南赛区 C/C++ 程序设计研究生组二等奖

长沙理工大学一等奖学金(2022-2023、2023-2024)、长沙理工大学优秀研究生(2022-2023)、CET-6



