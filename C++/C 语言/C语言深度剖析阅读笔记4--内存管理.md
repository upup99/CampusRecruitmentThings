## C语言深度剖析阅读笔记4--内存管理



### 1. 野指针

​	除了在使用时，别的时间都把指针“栓”在0地址处，这样他才会老实。不然有可能乱跑。

### 2. 栈、堆和静态区

- 静态区：**保存自动全局变量和static变量**（包括static全局和局部变量）。静态区的内容在总个程序的生命周期内都存在，由编译器在编译的时候分配。
- 栈：**保存局部变量**。栈上的内容只在函数的范围内存在，当函数运行结束，这些内容也会自动被销毁。其特点是效率高，但空间大小有限。
- 堆：**由malloc系列函数或new操作符分配的内存。其生命周期由free或delete决定。**在没有解释之前一直存在，直到程序结束。其特点是使用灵活，空间比较大，但容易出错。

### 3. 常见的内存错误及对策

#### 3.1 指针指向一块合法的内存

​	定义了指针变量，但是没有为指针分配内存，即指针没有指向一块合法的内存。

##### 3.1.1 结构体成员指针未初始化

##### 3.1.2 没有为结构体指针分配足够的内存

##### 3.1.3 函数的入口校验

​	**不管什么时候，我们使用指针之前一定要确保指针是有效的。**

​	一般在函数入口处使用assert(NULL != p)对参数进行校验。在非参数的地方使用if(NULL != p)。这都有一个要求，就是p在定义的时候同时被初始化为NULL了。

​	assert是一个宏，包含在assert.h头文件中。如果其后面括号里的值为假，则程序终止运行，并提示出错，反之继续。assert宏可以帮助我们定位错误。

#### 3.2 为指针分配的内存太小

```c
	char *p1 = "abcdefg";
	char *p2 = (char*)malloc(sizeof(char)*strlen(p1));
	strcpy(p2, p1);
```

​	p1是字符串常量，长度7个字符，但所占内存为8个byte。不要忘记了字符串常量的结束标志“\0”。上述操作就没有把结束标志复制过去，解决方法申请多一个sizeof(char)空间.

#### 3.3 内存分配成功，但并未初始化

​	犯这个错误往往是由于没有初始化的概念或者是以为内存分配好之后其值自然为0。这是一个严重的问题，因为往往发现不了。**所以在定义一个变量时，第一件事就是初始化**，如果定义数组的话可以用memset函数来初始化为0，`memset(a, 0, sizeof(a));`memset函数有三个参数，第一个（a）是要被设置的内存起始地址；第二个参数（0）是要被设置的值；第三个（sizeof(a)）是要被设置的内存大小，单位是byte。

#### 3.4 内存越界

​	这个是经常犯的错误，多在操作数组和指针是“多1”或“少1”。

#### 3.5 内存泄漏

​	内存泄漏几乎是很难避免的。

​	会产生泄漏的内存就是堆上的内存（这里不讨论资源或句柄等泄漏情况），也就是说由malloc系列函数或new操作符分配的内存。**如果用完之后没有及时free或delete，这块内存就无法释放·，直到整个程序终止。**

##### 3.5.1 如何使用malloc函数

​	使用malloc函数分配的空间具有连续性，不一定分配成功，内存分配失败函数会返回NULL，于是我们需要在使用时加上`if(NULL != p) `语句来验证。

##### 3.5.2 用malloc函数申请0字节内存

​	这样做会返回NULL指针吗？不会，但这块内存无用。

##### 3.5.3 内存释放

​	有分配，就有释放。与malloc对应的就是free函数，free函数只有一个参数，就是所要释放的内存块的首地址。**一定要一夫一妻制，不然会出错**，即一个malloc对应一个free，malloc多了会内存泄漏，free多了会因为没有内存释放而出错。

##### 3.5.4 内存释放之后

​	其实使用free函数之后指针变量p本身保存的地址并没有改变，那需要重新把p的值变为NULL，不这样“栓”起来迟早会出问题，这种指针就成为了野指针。

##### 3.5.5 内存已经被释放了，但是继续通过指针来使用

- 第一种：就是上面说的，free(p)之后，继续通过p指针来访问内存。解决的办法就是给p置NULL。
- 第二种：函数返回栈内存。这是初学者易犯的错误。比如在函数内部定义了一个数组，却用return语句返回指向该数组的指针。解决办法就是弄明白栈上变量的生命周期。
- 第三种：内存使用太复杂，弄不清到底哪块内存被释放，这种直接重开。